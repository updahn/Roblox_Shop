-- æ™®é€šç”¨æˆ·æœåŠ¡æ¨¡å—
-- å¤„ç†ç”¨æˆ·è®¤è¯ã€æ•°æ®è·å–ã€è´­ä¹°/å‡ºå”®ç­‰åŸºç¡€åŠŸèƒ½

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local UserService = {}

-- ç­‰å¾…æ¨¡å—
local SharedModules = ReplicatedStorage:WaitForChild("SharedModules")
local Config = require(SharedModules:WaitForChild("Config"))
local Events = require(SharedModules:WaitForChild("ShopEvents"))
local DataService = require(script.Parent:WaitForChild("DataService"))

-- ç©å®¶ä¼šè¯ç®¡ç†
local playerSessions = {} -- å­˜å‚¨å·²ç™»å½•çš„ç©å®¶

-- ==============================================
-- å†…éƒ¨å·¥å…·å‡½æ•°
-- ==============================================

local function getPlayerSession(player: Player)
    return playerSessions[player]
end

-- ==============================================
-- ç”¨æˆ·è®¤è¯å’Œç®¡ç†
-- ==============================================

function UserService.authenticatePlayer(player: Player)
    local userId = tostring(player.UserId)
    local username = player.Name
    local displayName = player.DisplayName ~= player.Name and player.DisplayName or nil

    local success, userData = DataService.authenticateUser(userId, username, displayName)
    if success then
        -- æ£€æŸ¥ç®¡ç†å‘˜æƒé™ï¼ˆä½¿ç”¨APIéªŒè¯ï¼‰
        local isApiAdmin = userData and userData.isAdmin
        local isValidAdminCheck, _ = DataService.checkAdminPermission(userId)
        local finalIsAdmin = isApiAdmin or isValidAdminCheck

        if isValidAdminCheck then
            print("âš¡ [è®¤è¯] " .. player.Name .. " é€šè¿‡APIæƒé™æ£€æŸ¥ç¡®è®¤ä¸ºç®¡ç†å‘˜")
        elseif isApiAdmin then
            print("âš¡ [è®¤è¯] " .. player.Name .. " é€šè¿‡ç”¨æˆ·æ•°æ®ç¡®è®¤ä¸ºç®¡ç†å‘˜")
        end

        playerSessions[player] = {
            userId = userId,
            userData = userData,
            authenticated = true,
            isAdmin = finalIsAdmin
        }

        -- å¤„ç†æ¯æ—¥ç™»å½•å¥–åŠ±ï¼ˆå¼‚æ­¥æ‰§è¡Œï¼‰
        spawn(function()
            local rewardSuccess, rewardMessage, rewardData = DataService.claimDailyRewards(userId)
            if rewardSuccess and rewardData and rewardData.totalRewards > 0 then
                print("ğŸ [æ¯æ—¥å¥–åŠ±] " .. player.Name .. " é¢†å–äº† " .. rewardData.totalRewards .. " é‡‘å¸")
                if rewardData.rewardedDays and rewardData.rewardedDays > 1 then
                    print("ğŸ“… [è¡¥å‘å¥–åŠ±] " .. player.Name .. " è¡¥å‘äº† " .. (rewardData.rewardedDays - 1) .. " å¤©çš„å¥–åŠ±")
                end
                -- å¯ä»¥åœ¨è¿™é‡Œé€šçŸ¥å®¢æˆ·ç«¯
            end
        end)

        print("âœ… [è®¤è¯] " .. player.Name .. " è®¤è¯æˆåŠŸ")
        return true
    else
        warn("âŒ [è®¤è¯] " .. player.Name .. " è®¤è¯å¤±è´¥")
        return false
    end
end

function UserService.cleanupPlayer(player: Player)
    if playerSessions[player] then
        local session = playerSessions[player]
        if session.userId then
            DataService.removeToken(session.userId)
        end
        playerSessions[player] = nil
    end
end

function UserService.isPlayerAuthenticated(player: Player): boolean
    local session = getPlayerSession(player)
    return session and session.authenticated and DataService.isAuthenticated(session.userId)
end

function UserService.isPlayerAdmin(player: Player): boolean
    -- ä½¿ç”¨APIæƒé™æ£€æŸ¥
    local userId = tostring(player.UserId)
    local isValidAdminCheck, _ = DataService.checkAdminPermission(userId)

    if isValidAdminCheck then
        print("âš¡ [UserService] " .. player.Name .. " é€šè¿‡APIæƒé™æ£€æŸ¥éªŒè¯ä¸ºç®¡ç†å‘˜")
        return true
    end

    -- å¤‡ç”¨ï¼šæ£€æŸ¥sessionä¸­çš„isAdminæ ‡å¿—
    local session = getPlayerSession(player)
    local sessionAdmin = session and session.isAdmin

    if sessionAdmin then
        print("âš¡ [UserService] " .. player.Name .. " é€šè¿‡sessionéªŒè¯ä¸ºç®¡ç†å‘˜")
        return true
    end

    print("âŒ [UserService] " .. player.Name .. " ä¸æ˜¯ç®¡ç†å‘˜")
    return false
end

-- ==============================================
-- æ•°æ®å¤„ç†å‡½æ•°
-- ==============================================

local function handleGetPlayerData(player: Player)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        -- å°è¯•é‡æ–°è®¤è¯
        if not UserService.authenticatePlayer(player) then
            Events.User.GetPlayerData:FireClient(player, nil)
            return
        end
        session = getPlayerSession(player)
    end

    -- è·å–æœ€æ–°çš„ç”¨æˆ·æ•°æ®
    local userData = DataService.getUserData(session.userId)
    if userData then
        local inventory = DataService.getUserInventory(session.userId)
        local membershipStatus = DataService.getMembershipStatus(session.userId)

        -- è·å–ç”¨æˆ·äº¤æ˜“è®°å½•
        local transactionSuccess, transactionData, _ = DataService.getUserTransactions(session.userId, 20, 0, nil)

        -- è½¬æ¢ä¸ºå®¢æˆ·ç«¯æ ¼å¼
        local playerData = {
            coins = userData.coins,
            inventory = inventory or {},
            membership = membershipStatus or {
                hasMembership = false,
                isValid = false,
                daysRemaining = 0,
                membershipType = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 0
            },
            stats = {
                totalPurchases = userData.total_purchases or 0,
                totalSales = userData.total_sales or 0,
                totalSpent = userData.total_spent or 0,
                totalEarned = userData.total_earned or 0
            },
            transactionHistory = {}
        }

        -- æ·»åŠ äº¤æ˜“è®°å½•åˆ°ç©å®¶æ•°æ®ä¸­
        if transactionSuccess and transactionData and transactionData.transactions then
            for _, transaction in ipairs(transactionData.transactions) do
                table.insert(playerData.transactionHistory, {
                    id = transaction.id,
                    itemId = transaction.item_id,
                    itemName = transaction.item_name,
                    type = transaction.type,
                    quantity = transaction.quantity,
                    unitPrice = transaction.unit_price,
                    totalAmount = transaction.total_amount,
                    transactionDate = transaction.transaction_date,
                    createdAt = transaction.created_at,
                    timestamp = transaction.created_at -- ä¸ºäº†å…¼å®¹æ€§
                })
            end
        end

        session.userData = userData
        Events.User.GetPlayerData:FireClient(player, playerData)
    else
        Events.User.GetPlayerData:FireClient(player, nil)
    end
end

local function handleGetShopData(player: Player)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        Events.User.GetShopData:FireClient(player, {})
        return
    end

    local shopItems = DataService.getShopItems()
    if shopItems then
        -- è½¬æ¢æ ¼å¼ä»¥ä¿æŒå…¼å®¹æ€§
        local shopData = {}
        for itemId, item in pairs(shopItems) do
            shopData[itemId] = {
                id = item.id,
                name = item.name,
                price = item.price,
                maxQuantity = item.max_quantity,
                currentStock = item.current_stock,
                description = item.description,
                icon = item.icon,
                imageId = item.image_id,
                category = item.category,
                sellPrice = item.sell_price
            }
        end

        Events.User.GetShopData:FireClient(player, shopData)
    else
        Events.User.GetShopData:FireClient(player, {})
    end
end

local function handleBuyItem(player: Player, itemId: string, quantity: number)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        Events.User.BuyItem:FireClient(player, false, "ç”¨æˆ·æœªè®¤è¯", nil)
        return
    end

    -- éªŒè¯è¾“å…¥
    if not itemId or quantity <= 0 then
        Events.User.BuyItem:FireClient(player, false, "æ— æ•ˆçš„å‚æ•°", nil)
        return
    end

    local success, message = DataService.buyItem(session.userId, itemId, quantity)

    if success then
        -- è·å–æ›´æ–°åçš„ç”¨æˆ·æ•°æ®
        local userData = DataService.getUserData(session.userId)
        local inventory = DataService.getUserInventory(session.userId)
        local membershipStatus = DataService.getMembershipStatus(session.userId)

        local playerData = {
            coins = userData.coins,
            inventory = inventory or {},
            membership = membershipStatus or {
                hasMembership = false,
                isValid = false,
                daysRemaining = 0,
                membershipType = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 0
            },
            stats = {
                totalPurchases = userData.total_purchases or 0,
                totalSales = userData.total_sales or 0,
                totalSpent = userData.total_spent or 0,
                totalEarned = userData.total_earned or 0
            }
        }

        session.userData = userData
        Events.User.BuyItem:FireClient(player, true, message, playerData)
        print("ğŸ›’ [è´­ä¹°] " .. player.Name .. " è´­ä¹°äº† " .. itemId .. " x" .. quantity)

        -- å¹¿æ’­å•†åº—æ•°æ®æ›´æ–°ç»™æ‰€æœ‰ç©å®¶
        for _, otherPlayer in pairs(Players:GetPlayers()) do
            handleGetShopData(otherPlayer)
        end
    else
        Events.User.BuyItem:FireClient(player, false, message or "è´­ä¹°å¤±è´¥", nil)
    end
end

local function handleSellItem(player: Player, itemId: string, quantity: number)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        Events.User.SellItem:FireClient(player, false, "ç”¨æˆ·æœªè®¤è¯", nil)
        return
    end

    -- éªŒè¯è¾“å…¥
    if not itemId or quantity <= 0 then
        Events.User.SellItem:FireClient(player, false, "æ— æ•ˆçš„å‚æ•°", nil)
        return
    end

    local success, message = DataService.sellItem(session.userId, itemId, quantity)

    if success then
        -- è·å–æ›´æ–°åçš„ç”¨æˆ·æ•°æ®
        local userData = DataService.getUserData(session.userId)
        local inventory = DataService.getUserInventory(session.userId)

        local playerData = {
            coins = userData.coins,
            inventory = inventory or {},
            stats = {
                totalPurchases = userData.total_purchases or 0,
                totalSales = userData.total_sales or 0,
                totalSpent = userData.total_spent or 0,
                totalEarned = userData.total_earned or 0
            }
        }

        session.userData = userData
        Events.User.SellItem:FireClient(player, true, message, playerData)
        print("ğŸ’° [å–å‡º] " .. player.Name .. " å–å‡ºäº† " .. itemId .. " x" .. quantity)

        -- å¹¿æ’­å•†åº—æ•°æ®æ›´æ–°ç»™æ‰€æœ‰ç©å®¶
        for _, otherPlayer in pairs(Players:GetPlayers()) do
            handleGetShopData(otherPlayer)
        end
    else
        Events.User.SellItem:FireClient(player, false, message or "å–å‡ºå¤±è´¥", nil)
    end
end

local function handleRefreshData(player: Player)
    -- åˆ·æ–°ç©å®¶æ•°æ®å’Œå•†åº—æ•°æ®
    handleGetPlayerData(player)
    handleGetShopData(player)
end

local function handleGetTransactions(player: Player, limit: number?, offset: number?, type: string?)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        Events.User.GetTransactions:FireClient(player, false, "ç”¨æˆ·æœªè®¤è¯", nil)
        return
    end

    -- è®¾ç½®é»˜è®¤å€¼
    local actualLimit = limit or 50
    local actualOffset = offset or 0

    -- éªŒè¯å‚æ•°
    if actualLimit <= 0 or actualLimit > 100 then
        actualLimit = 50
    end
    if actualOffset < 0 then
        actualOffset = 0
    end

    local success, data, errorMessage = DataService.getUserTransactions(
        session.userId,
        actualLimit,
        actualOffset,
        type
    )

    if success and data then
        -- è½¬æ¢äº¤æ˜“è®°å½•æ ¼å¼ä»¥ä¾›å®¢æˆ·ç«¯ä½¿ç”¨
        local clientTransactions = {}

        if data.transactions then
            for i, transaction in ipairs(data.transactions) do
                table.insert(clientTransactions, {
                    id = transaction.id,
                    itemId = transaction.item_id,
                    itemName = transaction.item_name,
                    type = transaction.type,
                    quantity = transaction.quantity,
                    unitPrice = transaction.unit_price,
                    totalAmount = transaction.total_amount,
                    transactionDate = transaction.transaction_date,
                    createdAt = transaction.created_at,
                    timestamp = transaction.created_at -- ä¸ºäº†å…¼å®¹æ€§
                })
            end
        end

        -- åŒ…å«åˆ†é¡µå’Œç»Ÿè®¡ä¿¡æ¯
        local responseData = {
            transactions = clientTransactions,
            pagination = data.pagination,
            stats = data.stats
        }

        Events.User.GetTransactions:FireClient(player, true, nil, responseData)
        print("ğŸ“Š [äº¤æ˜“è®°å½•] " .. player.Name .. " è·å–äº† " .. #clientTransactions .. " æ¡äº¤æ˜“è®°å½•")
    else
        local errorMsg = errorMessage or "è·å–äº¤æ˜“è®°å½•å¤±è´¥"
        Events.User.GetTransactions:FireClient(player, false, errorMsg, nil)
        print("âŒ [äº¤æ˜“è®°å½•] " .. player.Name .. " è·å–äº¤æ˜“è®°å½•å¤±è´¥: " .. errorMsg)
    end
end

-- ==============================================
-- äº‹ä»¶è¿æ¥
-- ==============================================

-- è¿æ¥ç”¨æˆ·äº‹ä»¶
Events.User.GetPlayerData.OnServerEvent:Connect(handleGetPlayerData)
Events.User.GetShopData.OnServerEvent:Connect(handleGetShopData)
Events.User.BuyItem.OnServerEvent:Connect(handleBuyItem)
Events.User.SellItem.OnServerEvent:Connect(handleSellItem)
Events.User.RefreshData.OnServerEvent:Connect(handleRefreshData)
Events.User.GetTransactions.OnServerEvent:Connect(handleGetTransactions)


print("ğŸ‘¤ æ™®é€šç”¨æˆ·æœåŠ¡å·²å¯åŠ¨")

return UserService
