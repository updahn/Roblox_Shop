-- æ— äººæœºç³»ç»ŸæœåŠ¡ç«¯æ¨¡å—
-- å¤„ç†æ— äººæœºçš„ç”Ÿæˆã€æ§åˆ¶ã€æ”»å‡»å’Œé”€æ¯é€»è¾‘

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local DroneService = {}

-- ç­‰å¾…æ¨¡å—
local SharedModules = ReplicatedStorage:WaitForChild("SharedModules")
local DroneConfig = require(SharedModules:WaitForChild("DroneConfig"))
local Events = require(SharedModules:WaitForChild("ShopEvents"))

-- æ´»è·ƒæ— äººæœºç®¡ç†
local activeDrones = {} -- [player] = droneData

-- ==============================================
-- å†…éƒ¨å·¥å…·å‡½æ•°
-- ==============================================

local function log(message, ...)
    DroneConfig.log("[æœåŠ¡ç«¯]", message, ...)
end

-- åˆ›å»ºæ”»å‡»ç‰¹æ•ˆ
local function createAttackEffect(startPos, endPos)
    if not DroneConfig.DRONE.EFFECTS.ATTACK_EFFECT then return end

    -- åˆ›å»ºæ¿€å…‰æŸç‰¹æ•ˆ
    local beam = Instance.new("Beam")
    local attachment1 = Instance.new("Attachment")
    local attachment2 = Instance.new("Attachment")

    -- åˆ›å»ºä¸´æ—¶éƒ¨ä»¶æ¥æ‰¿è½½attachment
    local part1 = Instance.new("Part")
    part1.Anchored = true
    part1.CanCollide = false
    part1.Transparency = 1
    part1.Size = Vector3.new(0.1, 0.1, 0.1)
    part1.Position = startPos
    part1.Parent = workspace

    local part2 = Instance.new("Part")
    part2.Anchored = true
    part2.CanCollide = false
    part2.Transparency = 1
    part2.Size = Vector3.new(0.1, 0.1, 0.1)
    part2.Position = endPos
    part2.Parent = workspace

    attachment1.Parent = part1
    attachment2.Parent = part2

    beam.Attachment0 = attachment1
    beam.Attachment1 = attachment2
    beam.Color = ColorSequence.new(DroneConfig.EFFECTS.ATTACK_EFFECT.BEAM_COLOR)
    beam.Width0 = DroneConfig.EFFECTS.ATTACK_EFFECT.BEAM_WIDTH
    beam.Width1 = DroneConfig.EFFECTS.ATTACK_EFFECT.BEAM_WIDTH
    beam.Parent = part1

    -- è‡ªåŠ¨æ¸…ç†
    Debris:AddItem(part1, DroneConfig.EFFECTS.ATTACK_EFFECT.BEAM_DURATION)
    Debris:AddItem(part2, DroneConfig.EFFECTS.ATTACK_EFFECT.BEAM_DURATION)
end

-- åˆ›å»ºçˆ†ç‚¸ç‰¹æ•ˆ
local function createExplosionEffect(position)
    if not DroneConfig.DRONE.EFFECTS.EXPLOSION_EFFECT then return end

    -- åˆ›å»ºçˆ†ç‚¸æ•ˆæœå®¹å™¨
    local effectPart = Instance.new("Part")
    effectPart.Name = "ExplosionEffect"
    effectPart.Anchored = true
    effectPart.CanCollide = false
    effectPart.Transparency = 1
    effectPart.Size = Vector3.new(0.1, 0.1, 0.1)
    effectPart.Position = position
    effectPart.Parent = workspace

    -- åˆ›å»ºçˆ†ç‚¸å…‰çƒ
    local explosionBall = Instance.new("Part")
    explosionBall.Name = "ExplosionBall"
    explosionBall.Anchored = true
    explosionBall.CanCollide = false
    explosionBall.Material = Enum.Material.ForceField
    explosionBall.BrickColor = BrickColor.new("Bright orange")
    explosionBall.Shape = Enum.PartType.Ball
    explosionBall.Size = Vector3.new(0.1, 0.1, 0.1)
    explosionBall.Position = position
    explosionBall.Parent = effectPart

    -- æ·»åŠ å‘å…‰æ•ˆæœ
    local pointLight = Instance.new("PointLight")
    pointLight.Color = Color3.fromRGB(255, 165, 0)
    pointLight.Brightness = 5
    pointLight.Range = 15
    pointLight.Parent = explosionBall

    -- åˆ›å»ºç²’å­æ•ˆæœ
    local attachment = Instance.new("Attachment")
    attachment.Parent = explosionBall

    -- ç«èŠ±ç²’å­
    local sparkParticles = Instance.new("ParticleEmitter")
    sparkParticles.Parent = attachment
    sparkParticles.Texture = "rbxasset://textures/particles/sparkles_main.dds"
    sparkParticles.Lifetime = NumberRange.new(0.3, 0.8)
    sparkParticles.Rate = 200
    sparkParticles.SpreadAngle = Vector2.new(360, 360)
    sparkParticles.Speed = NumberRange.new(10, 25)
    sparkParticles.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 0)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 165, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))
    }
    sparkParticles.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(0.5, 1),
        NumberSequenceKeypoint.new(1, 0)
    }

    -- çƒŸé›¾ç²’å­
    local smokeParticles = Instance.new("ParticleEmitter")
    smokeParticles.Parent = attachment
    smokeParticles.Texture = "rbxasset://textures/particles/smoke_main.dds"
    smokeParticles.Lifetime = NumberRange.new(1, 2)
    smokeParticles.Rate = 50
    smokeParticles.SpreadAngle = Vector2.new(45, 45)
    smokeParticles.Speed = NumberRange.new(5, 15)
    smokeParticles.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 100, 100)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 50))
    }
    smokeParticles.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(0.5, 2),
        NumberSequenceKeypoint.new(1, 3)
    }
    smokeParticles.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(1, 1)
    }

    -- çˆ†ç‚¸çƒæ‰©å±•åŠ¨ç”»
    local expandTween = TweenService:Create(
        explosionBall,
        TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Size = Vector3.new(8, 8, 8), Transparency = 1}
    )

    -- å…‰çº¿è¡°å‡åŠ¨ç”»
    local lightTween = TweenService:Create(
        pointLight,
        TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Brightness = 0, Range = 5}
    )

    -- æ’­æ”¾åŠ¨ç”»
    expandTween:Play()
    lightTween:Play()

    -- ä½¿ç”¨spawnæ¥å¼‚æ­¥åœæ­¢ç²’å­å‘å°„
    spawn(function()
        wait(0.1)
        sparkParticles.Enabled = false
        smokeParticles.Enabled = false
    end)

    -- æ¸…ç†æ•ˆæœ
    Debris:AddItem(effectPart, 3)

    log("åˆ›å»ºçˆ†ç‚¸ç‰¹æ•ˆäºä½ç½®:", position)
end

-- åˆ›å»ºç”Ÿæˆç‰¹æ•ˆ
local function createSpawnEffect(position)
    if not DroneConfig.DRONE.EFFECTS.SPAWN_EFFECT then return end

    -- åˆ›å»ºç²’å­å‘å°„å™¨
    local effectPart = Instance.new("Part")
    effectPart.Anchored = true
    effectPart.CanCollide = false
    effectPart.Transparency = 1
    effectPart.Size = Vector3.new(1, 1, 1)
    effectPart.Position = position
    effectPart.Parent = workspace

    local attachment = Instance.new("Attachment")
    attachment.Parent = effectPart

    local particles = Instance.new("ParticleEmitter")
    particles.Parent = attachment
    particles.Enabled = true
    particles.Lifetime = NumberRange.new(DroneConfig.EFFECTS.SPAWN_EFFECT.LIFETIME)
    particles.Rate = DroneConfig.EFFECTS.SPAWN_EFFECT.PARTICLE_COUNT
    particles.Color = ColorSequence.new(DroneConfig.EFFECTS.SPAWN_EFFECT.COLOR)
    particles.VelocityInheritance = 0.5
    particles.Speed = NumberRange.new(5, 15)

    -- åœæ­¢å‘å°„å¹¶æ¸…ç†
    spawn(function()
        wait(0.5)
        particles.Enabled = false
        Debris:AddItem(effectPart, DroneConfig.EFFECTS.SPAWN_EFFECT.LIFETIME + 1)
    end)
end

-- åˆ›å»ºé”€æ¯ç‰¹æ•ˆï¼ˆå·²ç¦ç”¨çˆ†ç‚¸æ•ˆæœï¼‰
local function createDestroyEffect(position)
    -- çˆ†ç‚¸æ•ˆæœå·²è¢«ç¦ç”¨ï¼Œæ— äººæœºæ¶ˆå¤±æ—¶ä¸å†æ˜¾ç¤ºçˆ†ç‚¸
    return

    --[[
    if not DroneConfig.DRONE.EFFECTS.DESTROY_EFFECT then return end

    -- åˆ›å»ºçˆ†ç‚¸ç‰¹æ•ˆ
    local explosion = Instance.new("Explosion")
    explosion.Position = position
    explosion.BlastRadius = 5
    explosion.BlastPressure = 0 -- ä¸äº§ç”Ÿç‰©ç†æ•ˆæœ
    explosion.Parent = workspace
    --]]
end

-- å°è¯•ä»å•ä¸ªæ¨¡å‹IDåŠ è½½æ— äººæœº
local function tryLoadModelFromId(assetId)
    -- æå–çº¯æ•°å­—IDï¼ˆå»æ‰rbxassetid://å‰ç¼€ï¼‰
    local numericId = assetId
    if string.find(assetId, "rbxassetid://") then
        numericId = string.gsub(assetId, "rbxassetid://", "")
    end

    -- è½¬æ¢ä¸ºæ•°å­—
    local assetNumber = tonumber(numericId)
    if not assetNumber then
        log("æ— æ•ˆçš„èµ„äº§IDæ ¼å¼ï¼š" .. assetId)
        return nil
    end

    local success, result = pcall(function()
        local insertService = game:GetService("InsertService")
        return insertService:LoadAsset(assetNumber)
    end)

    if success and result then
        log("âœ… æˆåŠŸä»ç½‘ç»œåŠ è½½æ¨¡å‹ï¼š" .. assetId .. " (æ•°å­—ID: " .. assetNumber .. ")")
        log("ğŸ“¦ æ¨¡å‹ç±»å‹ï¼š" .. result.ClassName)
        log("ğŸ“‚ æ¨¡å‹å­å¯¹è±¡æ•°é‡ï¼š" .. #result:GetChildren())

        -- æ‰“å°æ‰€æœ‰å­å¯¹è±¡ä¿¡æ¯ç”¨äºè°ƒè¯•
        for i, child in pairs(result:GetChildren()) do
            log("  â””â”€ å­å¯¹è±¡" .. i .. "ï¼š" .. child.Name .. " (" .. child.ClassName .. ")")
        end

        -- æŸ¥æ‰¾æ¨¡å‹ä¸­çš„æ— äººæœº
        for _, child in pairs(result:GetChildren()) do
            if child:IsA("Model") and child.Name ~= "Model" then
                log("æ‰¾åˆ°æ¨¡å‹å­å¯¹è±¡ï¼š" .. child.Name)
                -- æ‰¾åˆ°æ— äººæœºæ¨¡å‹ï¼Œè¿›è¡Œè®¾ç½®
                local drone = child:Clone()
                result:Destroy()

                -- ç¡®ä¿æ— äººæœºæœ‰PrimaryPart
                if not drone.PrimaryPart then
                    log("æ¨¡å‹æ²¡æœ‰PrimaryPartï¼Œå°è¯•æŸ¥æ‰¾ä¸»è¦éƒ¨ä»¶...")
                    -- å¯»æ‰¾ä¸»è¦éƒ¨ä»¶
                    local mainPart = drone:FindFirstChild("Body") or drone:FindFirstChild("Main") or drone:FindFirstChildOfClass("Part")
                    if mainPart then
                        drone.PrimaryPart = mainPart
                        log("è®¾ç½®PrimaryPartä¸ºï¼š" .. mainPart.Name)
                    else
                        log("æœªæ‰¾åˆ°åˆé€‚çš„ä¸»è¦éƒ¨ä»¶")
                    end
                end

                -- å¦‚æœæœ‰PrimaryPartï¼Œæ·»åŠ ç§»åŠ¨æ§åˆ¶
                if drone.PrimaryPart then
                    local body = drone.PrimaryPart

                    -- ç¡®ä¿éƒ¨ä»¶è®¾ç½®æ­£ç¡®
                    body.Anchored = false
                    body.CanCollide = false

                    -- æ·»åŠ æˆ–æ›´æ–°BodyPosition
                    local bodyPosition = body:FindFirstChild("BodyPosition")
                    if not bodyPosition then
                        bodyPosition = Instance.new("BodyPosition")
                        bodyPosition.Parent = body
                    end
                    bodyPosition.MaxForce = Vector3.new(8000, 8000, 8000)
                    bodyPosition.D = 3000
                    bodyPosition.P = 12000

                    log("æˆåŠŸé…ç½®æ— äººæœºæ¨¡å‹ï¼š" .. assetId .. "ï¼ŒPrimaryPartï¼š" .. body.Name)
                    return drone
                else
                    log("æ¨¡å‹æ²¡æœ‰æœ‰æ•ˆçš„PrimaryPartï¼Œè·³è¿‡")
                end
            end
        end

        -- å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­æ¨¡å‹ï¼Œå°è¯•ç›´æ¥ä½¿ç”¨åŠ è½½çš„æ¨¡å‹
        if result:IsA("Model") then
            log("å°è¯•ç›´æ¥ä½¿ç”¨åŠ è½½çš„æ¨¡å‹ä½œä¸ºæ— äººæœº")
            local drone = result:Clone()
            result:Destroy()

            -- ç¡®ä¿æ— äººæœºæœ‰PrimaryPart
            if not drone.PrimaryPart then
                log("ç›´æ¥æ¨¡å‹æ²¡æœ‰PrimaryPartï¼Œå°è¯•æŸ¥æ‰¾ä¸»è¦éƒ¨ä»¶...")
                local mainPart = drone:FindFirstChild("Body") or drone:FindFirstChild("Main") or drone:FindFirstChildOfClass("Part")
                if mainPart then
                    drone.PrimaryPart = mainPart
                    log("è®¾ç½®PrimaryPartä¸ºï¼š" .. mainPart.Name)
                end
            end

            if drone.PrimaryPart then
                local body = drone.PrimaryPart
                body.Anchored = false
                body.CanCollide = false

                local bodyPosition = body:FindFirstChild("BodyPosition")
                if not bodyPosition then
                    bodyPosition = Instance.new("BodyPosition")
                    bodyPosition.Parent = body
                end
                bodyPosition.MaxForce = Vector3.new(8000, 8000, 8000)
                bodyPosition.D = 3000
                bodyPosition.P = 12000

                log("æˆåŠŸé…ç½®ç›´æ¥æ¨¡å‹ï¼š" .. assetId)
                return drone
            end
        end

        result:Destroy()
        log("æ¨¡å‹" .. assetId .. "ç»“æ„ä¸ç¬¦åˆè¦æ±‚ï¼Œæ— æ³•ä½¿ç”¨")
    else
        local errorMsg = result or "æœªçŸ¥é”™è¯¯"
        log("âŒ æ— æ³•ä»ç½‘ç»œåŠ è½½æ¨¡å‹IDï¼š" .. assetId .. " (æ•°å­—ID: " .. (assetNumber or "æ— æ•ˆ") .. ")ï¼Œé”™è¯¯ï¼š" .. tostring(errorMsg))
    end

    return nil
end

-- åŠ è½½æ— äººæœºæ¨¡å‹
local function loadDroneModel()
    -- é¦–å…ˆå°è¯•åŠ è½½ä¸»è¦æ¨¡å‹
    local drone = tryLoadModelFromId(DroneConfig.MODEL.ASSET_ID)
    if drone then
        return drone
    end

    -- å¦‚æœä¸»è¦æ¨¡å‹å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æ¨¡å‹
    if DroneConfig.MODEL.FALLBACK_ASSET_IDS then
        for _, fallbackId in ipairs(DroneConfig.MODEL.FALLBACK_ASSET_IDS) do
            if fallbackId ~= DroneConfig.MODEL.ASSET_ID then -- é¿å…é‡å¤å°è¯•ä¸»è¦æ¨¡å‹
                drone = tryLoadModelFromId(fallbackId)
                if drone then
                    return drone
                end
            end
        end
    end

    -- æ‰€æœ‰å¤–éƒ¨æ¨¡å‹éƒ½å¤±è´¥ï¼Œä½¿ç”¨å†…ç½®å¤‡ç”¨æ¨¡å‹
    log("æ‰€æœ‰å¤–éƒ¨æ¨¡å‹éƒ½æ— æ³•åŠ è½½ï¼Œä½¿ç”¨å†…ç½®å¤‡ç”¨æ¨¡å‹")
    local drone = Instance.new("Model")
    drone.Name = "Drone"

    -- ä¸»ä½“
    local body = Instance.new("Part")
    body.Name = "Body"
    body.Material = Enum.Material.ForceField
    body.BrickColor = BrickColor.new("Bright blue")
    body.Shape = Enum.PartType.Ball
    body.Size = Vector3.new(3, 3, 3)
    body.Anchored = false
    body.CanCollide = false
    body.TopSurface = Enum.SurfaceType.Smooth
    body.BottomSurface = Enum.SurfaceType.Smooth
    body.Parent = drone

    -- æ·»åŠ å‘å…‰æ•ˆæœ
    local pointLight = Instance.new("PointLight")
    pointLight.Color = Color3.fromRGB(0, 162, 255)
    pointLight.Brightness = 2
    pointLight.Range = 10
    pointLight.Parent = body

    -- æ·»åŠ BodyPositionç”¨äºä½ç½®æ§åˆ¶ï¼ˆæ›´é€‚åˆæ— äººæœºçš„æ‚¬åœç§»åŠ¨ï¼‰
    local bodyPosition = Instance.new("BodyPosition")
    bodyPosition.MaxForce = Vector3.new(8000, 8000, 8000)
    bodyPosition.Position = Vector3.new(0, 0, 0)
    bodyPosition.D = 3000 -- å¢åŠ é˜»å°¼ä»¥å‡å°‘éœ‡è¡
    bodyPosition.P = 12000 -- å¢åŠ åŠŸç‡ä»¥æé«˜å“åº”é€Ÿåº¦
    bodyPosition.Parent = body

    -- æ·»åŠ BodyAngularVelocityç”¨äºç¨³å®šæ—‹è½¬
    local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
    bodyAngularVelocity.MaxTorque = Vector3.new(4000, 4000, 4000)
    bodyAngularVelocity.AngularVelocity = Vector3.new(0, 0, 0)
    bodyAngularVelocity.Parent = body

    -- PrimaryPartè®¾ç½®
    drone.PrimaryPart = body

    return drone
end

-- æŸ¥æ‰¾æ”»å‡»ç›®æ ‡
local function findNearestTarget(dronePosition, attackRange, ownerPlayer)
    local nearestTarget = nil
    local nearestDistance = attackRange
    local targetType = "none"  -- "target", "player", "npc", "none"

    -- ä¼˜å…ˆæŸ¥æ‰¾é¶å­ï¼ˆåœ¨Workspace.Targetsæ–‡ä»¶å¤¹ä¸­ï¼‰
    local targetsFolder = workspace:FindFirstChild("Targets")
    if targetsFolder then
        for _, targetModel in pairs(targetsFolder:GetChildren()) do
            -- æ£€æŸ¥é¶å­æ˜¯å¦æ˜¯æœ‰æ•ˆçš„Modelå¹¶ä¸”æœ‰æ´»è·ƒçš„Baseéƒ¨ä»¶
            if targetModel:IsA("Model") then
                local basePart = targetModel:FindFirstChild("Base")
                if basePart and basePart:IsA("Part") and basePart.Transparency == 0 then
                    local distance = (basePart.Position - dronePosition).Magnitude
                    if distance < nearestDistance then
                        nearestTarget = basePart  -- è¿”å›Baseéƒ¨ä»¶ä½œä¸ºæ”»å‡»ç›®æ ‡
                        nearestDistance = distance
                        targetType = "target"
                    end
                end
            end
        end
    end

    -- å¦‚æœæ²¡æœ‰æ‰¾åˆ°é¶å­ï¼Œå†æŸ¥æ‰¾èŒƒå›´å†…çš„ç©å®¶ï¼ˆé™¤äº†æ‹¥æœ‰è€…ï¼‰
    if not nearestTarget then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= ownerPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - dronePosition).Magnitude
                if distance < nearestDistance then
                    nearestTarget = player.Character
                    nearestDistance = distance
                    targetType = "player"
                end
            end
        end
    end

    -- æœ€åæŸ¥æ‰¾èŒƒå›´å†…çš„NPCï¼ˆæŸ¥æ‰¾Humanoidä½†ä¸æ˜¯ç©å®¶çš„è§’è‰²ï¼‰
    if not nearestTarget then
        for _, obj in pairs(workspace:GetChildren()) do
            if obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj:FindFirstChild("HumanoidRootPart") then
                -- æ£€æŸ¥æ˜¯å¦æ˜¯ç©å®¶è§’è‰²
                local isPlayerCharacter = false
                for _, player in pairs(Players:GetPlayers()) do
                    if player.Character == obj then
                        isPlayerCharacter = true
                        break
                    end
                end

                if not isPlayerCharacter then
                    local distance = (obj.HumanoidRootPart.Position - dronePosition).Magnitude
                    if distance < nearestDistance then
                        nearestTarget = obj
                        nearestDistance = distance
                        targetType = "npc"
                    end
                end
            end
        end
    end

    return nearestTarget, targetType
end

-- æ— äººæœºæ”»å‡»ç›®æ ‡
local function attackTarget(drone, target, targetType)
    local body = drone.PrimaryPart
    if not body or not target then
        return false
    end

    -- éªŒè¯ç›®æ ‡æ˜¯å¦ä»ç„¶å­˜åœ¨
    if targetType == "target" then
        -- æ£€æŸ¥é¶å­æ˜¯å¦è¿˜åœ¨Targetsæ–‡ä»¶å¤¹ä¸­å¹¶ä¸”å¯è§ï¼ˆé€æ˜åº¦ä¸º0è¡¨ç¤ºå¯è§ï¼Œé€æ˜åº¦ä¸º1è¡¨ç¤ºéšè—ï¼‰
        local targetsFolder = workspace:FindFirstChild("Targets")
        local targetModel = target.Parent
        if not targetsFolder or not targetModel or targetModel.Parent ~= targetsFolder or target.Transparency == 1 then
            log("ç›®æ ‡é¶å­å·²æ¶ˆå¤±æˆ–è¢«éšè—ï¼Œå–æ¶ˆæ”»å‡»")
            return false
        end
    else
        -- æ£€æŸ¥ç©å®¶æˆ–NPCæ˜¯å¦ä»ç„¶æœ‰æ•ˆ
        if not target.Parent or not target:FindFirstChild("HumanoidRootPart") then
            log("ç›®æ ‡è§’è‰²å·²æ¶ˆå¤±ï¼Œå–æ¶ˆæ”»å‡»")
            return false
        end
    end

    local targetPos
    local dronePos = body.Position

    -- æ ¹æ®ç›®æ ‡ç±»å‹è·å–ä½ç½®
    if targetType == "target" then
        -- é¶å­æ˜¯Partå¯¹è±¡
        targetPos = target.Position
    else
        -- ç©å®¶æˆ–NPCæœ‰HumanoidRootPart
        if not target:FindFirstChild("HumanoidRootPart") then
            return false
        end
        targetPos = target.HumanoidRootPart.Position
    end

    -- åˆ›å»ºæ”»å‡»ç‰¹æ•ˆ
    createAttackEffect(dronePos, targetPos)

    -- æ ¹æ®ç›®æ ‡ç±»å‹å¤„ç†ä¼¤å®³
    if targetType == "target" then
        -- æ”»å‡»é¶å­ - é€šè¿‡TargetServiceå¤„ç†
        local targetModel = target.Parent  -- targetæ˜¯Baseéƒ¨ä»¶ï¼Œå…¶çˆ¶çº§æ˜¯Model
        local targetId = targetModel.Name
        local ownerName = drone.Owner.Value.Name

        -- ç›´æ¥åœ¨æœåŠ¡ç«¯å¤„ç†é¶å­ä¼¤å®³ - è·å–TargetService
        local success, TargetService = pcall(function()
            return require(script.Parent:WaitForChild("TargetService"))
        end)

        if success and TargetService then
            local destroyed = TargetService.damageTarget(targetId, DroneConfig.DRONE.ATTACK_DAMAGE, ownerName)
            log("ğŸ”¥ æ— äººæœºæ”»å‡»é¶å­:", targetId, "é€ æˆä¼¤å®³:", DroneConfig.DRONE.ATTACK_DAMAGE, destroyed and "(è¢«æ‘§æ¯)" or "")

            -- å¦‚æœé¶å­è¢«æ‘§æ¯ï¼Œåˆ›å»ºçˆ†ç‚¸æ•ˆæœ
            if destroyed then
                createExplosionEffect(targetPos)
            end
        else
            log("âŒ æ— æ³•è·å–TargetServiceæ¥å¤„ç†é¶å­ä¼¤å®³")
        end
    else
        -- æ”»å‡»ç©å®¶æˆ–NPC
        local humanoid = target:FindFirstChild("Humanoid")
        if humanoid then
            local oldHealth = humanoid.Health
            humanoid.Health = humanoid.Health - DroneConfig.DRONE.ATTACK_DAMAGE
            log("æ”»å‡»ç›®æ ‡:", target.Name, "é€ æˆä¼¤å®³:", DroneConfig.DRONE.ATTACK_DAMAGE)

            -- å¦‚æœç›®æ ‡è¢«å‡»è´¥ï¼Œåˆ›å»ºçˆ†ç‚¸æ•ˆæœ
            if humanoid.Health <= 0 and oldHealth > 0 then
                createExplosionEffect(targetPos)
            end
        end
    end

    -- æ’­æ”¾æ”»å‡»éŸ³æ•ˆ
    local sound = Instance.new("Sound")
    sound.SoundId = DroneConfig.SOUNDS.ATTACK
    sound.Volume = DroneConfig.SOUNDS.VOLUME.ATTACK
    sound.Parent = body
    sound:Play()

    -- æ¸…ç†éŸ³æ•ˆ
    sound.Ended:Connect(function()
        sound:Destroy()
    end)

    return true
end

-- æ— äººæœºç§»åŠ¨é€»è¾‘
local function updateDroneMovement(droneData)
    local drone = droneData.model
    local player = droneData.owner
    local mode = droneData.mode

    if not drone or not drone.PrimaryPart or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    local body = drone.PrimaryPart
    local bodyPosition = body:FindFirstChild("BodyPosition")
    if not bodyPosition then
        log("è­¦å‘Š: æ— äººæœºç¼ºå°‘BodyPositionç»„ä»¶")
        return
    end

    local playerPos = player.Character.HumanoidRootPart.Position
    local currentPos = body.Position
    local targetPos

    if mode == DroneConfig.MODES.FOLLOW then
        -- è·Ÿéšæ¨¡å¼ï¼šæ ¹æ®ç©å®¶æœå‘æ™ºèƒ½è·Ÿéš
        local humanoidRootPart = player.Character.HumanoidRootPart
        local lookDirection = humanoidRootPart.CFrame.LookVector

        -- è®¡ç®—è·Ÿéšä½ç½®ï¼ˆåœ¨ç©å®¶èº«åä¸Šæ–¹ï¼‰
        local behindOffset = -lookDirection * DroneConfig.DRONE.FOLLOW_DISTANCE
        local heightOffset = Vector3.new(0, DroneConfig.DRONE.FOLLOW_HEIGHT, 0)
        targetPos = playerPos + behindOffset + heightOffset

        -- æ·»åŠ ä¸€äº›éšæœºåç§»ä»¥é¿å…è¿‡äºåƒµç¡¬çš„è·Ÿéš
        local randomOffset = Vector3.new(
            (math.random() - 0.5) * 2,
            (math.random() - 0.5) * 1,
            (math.random() - 0.5) * 2
        )
        targetPos = targetPos + randomOffset
    else
        -- é©»å®ˆæ¨¡å¼ï¼šä¿æŒåœ¨è®¾å®šçš„ä½ç½®
        if not droneData.guardPosition then
            -- å¦‚æœæ²¡æœ‰è®¾å®šé©»å®ˆä½ç½®ï¼Œä½¿ç”¨å½“å‰ä½ç½®
            droneData.guardPosition = currentPos
        end
        targetPos = droneData.guardPosition
    end

    -- æ›´æ–°ç›®æ ‡ä½ç½®
    bodyPosition.Position = targetPos

    -- è°ƒè¯•ä¿¡æ¯
    if DroneConfig.DEBUG.VERBOSE_LOGGING then
        local distance = (currentPos - targetPos).Magnitude
        if distance > 1 then
            log("æ— äººæœºç§»åŠ¨:", player.Name, "æ¨¡å¼:", mode, "è·ç¦»ç›®æ ‡:", math.floor(distance), "studs")
        end
    end
end

-- ==============================================
-- æ— äººæœºç®¡ç†å‡½æ•°
-- ==============================================

function DroneService.spawnDrone(player: Player)
    -- æ£€æŸ¥ç©å®¶æ˜¯å¦å·²æœ‰æ— äººæœº
    if activeDrones[player] then
        return false, "æ‚¨å·²ç»æœ‰ä¸€ä¸ªæ´»è·ƒçš„æ— äººæœºäº†"
    end

    -- æ£€æŸ¥ç©å®¶è§’è‰²æ˜¯å¦å­˜åœ¨
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false, "æ— æ³•è·å–ç©å®¶ä½ç½®"
    end

    -- åŠ è½½æ— äººæœºæ¨¡å‹
    local droneModel = loadDroneModel()
    if not droneModel then
        return false, "æ— æ³•åŠ è½½æ— äººæœºæ¨¡å‹"
    end

    -- è®¾ç½®æ— äººæœºä½ç½®
    local playerPos = player.Character.HumanoidRootPart.Position
    local spawnPos = playerPos + Vector3.new(0, DroneConfig.DRONE.FOLLOW_HEIGHT, -DroneConfig.DRONE.FOLLOW_DISTANCE)

    droneModel:SetPrimaryPartCFrame(CFrame.new(spawnPos))
    droneModel.Parent = workspace

    -- åˆ›å»ºç”Ÿæˆç‰¹æ•ˆ
    createSpawnEffect(spawnPos)

    -- æ’­æ”¾ç”ŸæˆéŸ³æ•ˆ
    local sound = Instance.new("Sound")
    sound.SoundId = DroneConfig.SOUNDS.SPAWN
    sound.Volume = DroneConfig.SOUNDS.VOLUME.SPAWN
    sound.Parent = droneModel.PrimaryPart
    sound:Play()
    sound.Ended:Connect(function()
        sound:Destroy()
    end)

    -- æ·»åŠ Ownerå±æ€§åˆ°æ— äººæœºæ¨¡å‹
    local ownerValue = Instance.new("ObjectValue")
    ownerValue.Name = "Owner"
    ownerValue.Value = player
    ownerValue.Parent = droneModel

    -- åˆ›å»ºæ— äººæœºæ•°æ®
    local droneData = {
        model = droneModel,
        owner = player,
        mode = DroneConfig.MODES.FOLLOW,
        spawnTime = tick(),
        lastAttackTime = 0,
        guardPosition = nil
    }

    activeDrones[player] = droneData

    -- é€šçŸ¥å®¢æˆ·ç«¯
    Events.Drone.DroneSpawned:FireClient(player, true)

    log("ç©å®¶", player.Name, "å¬å”¤äº†æ— äººæœº")

    return true, "æ— äººæœºå·²å¬å”¤"
end

function DroneService.recallDrone(player: Player)
    local droneData = activeDrones[player]
    if not droneData then
        return false, "æ‚¨æ²¡æœ‰æ´»è·ƒçš„æ— äººæœº"
    end

    -- åˆ›å»ºé”€æ¯ç‰¹æ•ˆ
    if droneData.model and droneData.model.PrimaryPart then
        createDestroyEffect(droneData.model.PrimaryPart.Position)
    end

    -- é”€æ¯æ— äººæœºæ¨¡å‹
    if droneData.model then
        droneData.model:Destroy()
    end

    -- æ¸…é™¤æ•°æ®
    activeDrones[player] = nil

    -- é€šçŸ¥å®¢æˆ·ç«¯
    Events.Drone.DroneRecalled:FireClient(player, true)

    log("ç©å®¶", player.Name, "æ”¶å›äº†æ— äººæœº")

    return true, "æ— äººæœºå·²æ”¶å›"
end

function DroneService.switchDroneMode(player: Player, newMode: string)
    local droneData = activeDrones[player]
    if not droneData then
        return false, "æ‚¨æ²¡æœ‰æ´»è·ƒçš„æ— äººæœº"
    end

    if newMode ~= DroneConfig.MODES.FOLLOW and newMode ~= DroneConfig.MODES.GUARD then
        return false, "æ— æ•ˆçš„æ¨¡å¼"
    end

    local oldMode = droneData.mode
    droneData.mode = newMode

    -- å¦‚æœåˆ‡æ¢åˆ°é©»å®ˆæ¨¡å¼ï¼Œè®°å½•å½“å‰ä½ç½®
    if newMode == DroneConfig.MODES.GUARD and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local playerPos = player.Character.HumanoidRootPart.Position
        droneData.guardPosition = playerPos + Vector3.new(0, DroneConfig.DRONE.HOVER_HEIGHT, 0)
    end

    -- é€šçŸ¥å®¢æˆ·ç«¯
    Events.Drone.DroneModeChanged:FireClient(player, newMode, oldMode)

    log("ç©å®¶", player.Name, "å°†æ— äººæœºæ¨¡å¼ä»", oldMode, "åˆ‡æ¢åˆ°", newMode)

    return true, "æ¨¡å¼å·²åˆ‡æ¢åˆ°" .. (newMode == DroneConfig.MODES.FOLLOW and "è·Ÿéšæ¨¡å¼" or "é©»å®ˆæ¨¡å¼")
end

function DroneService.getDroneInfo(player: Player)
    local droneData = activeDrones[player]
    if not droneData then
        return nil
    end

    local currentTime = tick()
    local timeRemaining = math.max(0, DroneConfig.DRONE.LIFETIME - (currentTime - droneData.spawnTime))

    return {
        mode = droneData.mode,
        timeRemaining = timeRemaining,
        isActive = timeRemaining > 0
    }
end

-- ==============================================
-- ä¸»å¾ªç¯å’Œäº‹ä»¶å¤„ç†
-- ==============================================

local function mainLoop()
    local currentTime = tick()

    for player, droneData in pairs(activeDrones) do
        -- æ£€æŸ¥æ— äººæœºæ˜¯å¦è¶…æ—¶
        local timeElapsed = currentTime - droneData.spawnTime
        if timeElapsed >= DroneConfig.DRONE.LIFETIME then
            -- è‡ªåŠ¨é”€æ¯æ— äººæœº
            createDestroyEffect(droneData.model.PrimaryPart.Position)
            droneData.model:Destroy()
            activeDrones[player] = nil

            -- é€šçŸ¥å®¢æˆ·ç«¯
            Events.Drone.DroneDestroyed:FireClient(player, "æ—¶é—´åˆ°æœŸ")
            log("ç©å®¶", player.Name, "çš„æ— äººæœºå› æ—¶é—´åˆ°æœŸè€Œé”€æ¯")
            continue
        end

        -- æ›´æ–°æ— äººæœºç§»åŠ¨
        updateDroneMovement(droneData)

        -- æ”»å‡»é€»è¾‘
        if (currentTime - droneData.lastAttackTime) >= DroneConfig.DRONE.ATTACK_INTERVAL then
            local dronePos = droneData.model.PrimaryPart.Position
            local target, targetType = findNearestTarget(dronePos, DroneConfig.DRONE.ATTACK_RANGE, player)

            if target then
                local attackSuccess = attackTarget(droneData.model, target, targetType)
                if attackSuccess then
                    droneData.lastAttackTime = currentTime

                    -- é€šçŸ¥å®¢æˆ·ç«¯æ”»å‡»äº‹ä»¶
                    local targetName = targetType == "target" and (target.Parent and target.Parent.Name or target.Name) or target.Name
                    Events.Drone.DroneAttack:FireClient(player, targetName)
                    log("âœ… æ— äººæœºæ”»å‡»æˆåŠŸï¼šç±»å‹=" .. targetType .. ", ç›®æ ‡=" .. targetName)
                else
                    -- æ”»å‡»å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç›®æ ‡å·²æ¶ˆå¤±ï¼Œé‡ç½®æ”»å‡»æ—¶é—´ä»¥ä¾¿ç«‹å³å¯»æ‰¾æ–°ç›®æ ‡
                    droneData.lastAttackTime = currentTime - DroneConfig.DRONE.ATTACK_INTERVAL + 0.1
                end
            end
        end
    end
end

-- å¯åŠ¨ä¸»å¾ªç¯
local connection = RunService.Heartbeat:Connect(mainLoop)

-- ç©å®¶ç¦»å¼€æ—¶æ¸…ç†
Players.PlayerRemoving:Connect(function(player)
    if activeDrones[player] then
        if activeDrones[player].model then
            activeDrones[player].model:Destroy()
        end
        activeDrones[player] = nil
    end
end)

-- ==============================================
-- äº‹ä»¶è¿æ¥
-- ==============================================

Events.Drone.SpawnDrone.OnServerEvent:Connect(function(player)
    local success, message = DroneService.spawnDrone(player)
    -- å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å®¢æˆ·ç«¯åé¦ˆ
end)

Events.Drone.RecallDrone.OnServerEvent:Connect(function(player)
    local success, message = DroneService.recallDrone(player)
    -- å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å®¢æˆ·ç«¯åé¦ˆ
end)

Events.Drone.SwitchDroneMode.OnServerEvent:Connect(function(player, newMode)
    local success, message = DroneService.switchDroneMode(player, newMode)
    -- å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å®¢æˆ·ç«¯åé¦ˆ
end)

log("æ— äººæœºæœåŠ¡å·²å¯åŠ¨")

return DroneService
