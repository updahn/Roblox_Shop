--[[
    ç»Ÿä¸€ç¼“å­˜ç®¡ç†å™¨

    åŠŸèƒ½ç‰¹æ€§ï¼š
    - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ç±»å‹çš„ç¼“å­˜
    - åŸºäº MessagingService çš„è·¨æœåŠ¡å™¨ç¼“å­˜åŒæ­¥
    - è‡ªåŠ¨ç¼“å­˜æ¸…ç†å’Œè¿‡æœŸå¤„ç†
    - æ”¯æŒä¸åŒç¼“å­˜ç­–ç•¥ï¼ˆTTLã€LRUç­‰ï¼‰
    - ç¼“å­˜ç»Ÿè®¡å’Œç›‘æ§

    ä½¿ç”¨ç¤ºä¾‹ï¼š
        local CacheManager = require(path.to.CacheManager)

        -- è®¾ç½®ç¼“å­˜
        CacheManager.set("users", "123456", userData, 300) -- TTL 5åˆ†é’Ÿ

        -- è·å–ç¼“å­˜
        local cached = CacheManager.get("users", "123456")

        -- æ¸…ç†ç‰¹å®šç¼“å­˜
        CacheManager.invalidate("users", "123456")

        -- å¹¿æ’­ç¼“å­˜æ›´æ–°
        CacheManager.broadcast("users", "123456", "update")
]]

local MessagingService = game:GetService("MessagingService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

-- ç¯å¢ƒç®¡ç†å™¨
local EnvironmentManager = require(script.Parent.EnvironmentManager)

local CacheManager = {}

-- ==============================================
-- é…ç½®å¸¸é‡
-- ==============================================

-- ç¼“å­˜ç±»å‹æšä¸¾
local CacheType = {
    USER_DATA = "users",               -- ç”¨æˆ·åŸºç¡€æ•°æ®
    USER_INVENTORY = "inventory",      -- ç”¨æˆ·åº“å­˜
    MEMBERSHIP = "membership",         -- ä¼šå‘˜çŠ¶æ€
    ADMIN_PERMISSIONS = "admin",       -- ç®¡ç†å‘˜æƒé™
    SHOP_ITEMS = "shop_items",         -- å•†å“ä¿¡æ¯
    SYSTEM_CONFIG = "system_config",   -- ç³»ç»Ÿé…ç½®
    TRANSACTIONS = "transactions",      -- äº¤æ˜“è®°å½•ç¼“å­˜
    DAILY_REWARDS = "daily_rewards"    -- æ¯æ—¥å¥–åŠ±è®°å½•
}

-- é»˜è®¤ç¼“å­˜é…ç½®
local DEFAULT_CONFIG = {
    ttl = 300,              -- é»˜è®¤TTL 5åˆ†é’Ÿ
    maxSize = 1000,         -- æœ€å¤§ç¼“å­˜æ¡ç›®æ•°
    cleanupInterval = 60,   -- æ¸…ç†é—´éš”ï¼ˆç§’ï¼‰
    enableBroadcast = true, -- æ˜¯å¦å¯ç”¨è·¨æœåŠ¡å™¨å¹¿æ’­
    enableStats = true      -- æ˜¯å¦å¯ç”¨ç»Ÿè®¡
}

-- ä¸åŒç¼“å­˜ç±»å‹çš„ä¸“ç”¨é…ç½®
local CACHE_CONFIGS = {
    [CacheType.USER_DATA] = {
        ttl = 600,              -- ç”¨æˆ·æ•°æ®ç¼“å­˜10åˆ†é’Ÿ
        maxSize = 500,
        enableBroadcast = true
    },
    [CacheType.USER_INVENTORY] = {
        ttl = 300,              -- åº“å­˜ç¼“å­˜5åˆ†é’Ÿ
        maxSize = 500,
        enableBroadcast = true
    },
    [CacheType.MEMBERSHIP] = {
        ttl = 300,              -- ä¼šå‘˜çŠ¶æ€ç¼“å­˜5åˆ†é’Ÿ
        maxSize = 200,
        enableBroadcast = true
    },
    [CacheType.ADMIN_PERMISSIONS] = {
        ttl = 180,              -- ç®¡ç†å‘˜æƒé™ç¼“å­˜3åˆ†é’Ÿ
        maxSize = 50,
        enableBroadcast = true
    },
    [CacheType.SHOP_ITEMS] = {
        ttl = 1800,             -- å•†å“ä¿¡æ¯ç¼“å­˜30åˆ†é’Ÿ
        maxSize = 200,
        enableBroadcast = true
    },
    [CacheType.SYSTEM_CONFIG] = {
        ttl = 3600,             -- ç³»ç»Ÿé…ç½®ç¼“å­˜1å°æ—¶
        maxSize = 100,
        enableBroadcast = true
    },
    [CacheType.TRANSACTIONS] = {
        ttl = 180,              -- äº¤æ˜“è®°å½•ç¼“å­˜3åˆ†é’Ÿ
        maxSize = 300,
        enableBroadcast = false  -- äº¤æ˜“è®°å½•ä¸éœ€è¦è·¨æœåŠ¡å™¨åŒæ­¥
    },
    [CacheType.DAILY_REWARDS] = {
        ttl = 900,              -- æ¯æ—¥å¥–åŠ±ç¼“å­˜15åˆ†é’Ÿ
        maxSize = 200,
        enableBroadcast = true
    }
}

-- ==============================================
-- å†…éƒ¨æ•°æ®ç»“æ„
-- ==============================================

-- ç¼“å­˜å­˜å‚¨ {cacheType: {key: cacheEntry}}
local caches = {}

-- ç¼“å­˜ç»Ÿè®¡
local stats = {
    hits = {},       -- å‘½ä¸­æ¬¡æ•°
    misses = {},     -- æœªå‘½ä¸­æ¬¡æ•°
    sets = {},       -- è®¾ç½®æ¬¡æ•°
    invalidations = {}, -- å¤±æ•ˆæ¬¡æ•°
    broadcasts = {},    -- å¹¿æ’­æ¬¡æ•°
    totalMemory = 0,    -- æ€»å†…å­˜ä½¿ç”¨ï¼ˆä¼°ç®—ï¼‰
    lastCleanup = 0     -- ä¸Šæ¬¡æ¸…ç†æ—¶é—´
}

-- æœåŠ¡å™¨æ ‡è¯†ï¼ˆç”¨äºé¿å…å¹¿æ’­å›ç¯ï¼‰
local serverId = HttpService:GenerateGUID(false)

-- æ˜¯å¦å¯ç”¨ï¼ˆåœ¨Studioç¯å¢ƒä¸­å¯èƒ½ç¦ç”¨MessagingServiceï¼‰
local isEnabled = not EnvironmentManager.isStudio()

-- ==============================================
-- å·¥å…·å‡½æ•°
-- ==============================================

-- åˆ›å»ºç¼“å­˜æ¡ç›®
local function createCacheEntry(value, ttl)
    return {
        value = value,
        createdAt = os.time(),
        expiresAt = os.time() + (ttl or DEFAULT_CONFIG.ttl),
        accessCount = 0,
        lastAccessed = os.time(),
        size = string.len(HttpService:JSONEncode(value))
    }
end

-- æ£€æŸ¥ç¼“å­˜æ¡ç›®æ˜¯å¦è¿‡æœŸ
local function isExpired(entry)
    return os.time() > entry.expiresAt
end

-- åˆå§‹åŒ–ç¼“å­˜ç±»å‹å­˜å‚¨
local function initializeCacheType(cacheType)
    if not caches[cacheType] then
        caches[cacheType] = {}
        stats.hits[cacheType] = 0
        stats.misses[cacheType] = 0
        stats.sets[cacheType] = 0
        stats.invalidations[cacheType] = 0
        stats.broadcasts[cacheType] = 0
    end
end

-- è·å–ç¼“å­˜é…ç½®
local function getCacheConfig(cacheType)
    local config = CACHE_CONFIGS[cacheType] or {}
    local merged = {}

    -- åˆå¹¶é»˜è®¤é…ç½®
    for key, value in pairs(DEFAULT_CONFIG) do
        merged[key] = config[key] ~= nil and config[key] or value
    end

    return merged
end

-- ä¼°ç®—å†…å­˜ä½¿ç”¨
local function updateMemoryStats()
    local totalSize = 0
    for cacheType, cache in pairs(caches) do
        for key, entry in pairs(cache) do
            totalSize = totalSize + entry.size
        end
    end
    stats.totalMemory = totalSize
end

-- ==============================================
-- MessagingService å¹¿æ’­ç³»ç»Ÿ
-- ==============================================

-- å¹¿æ’­æ¶ˆæ¯ç±»å‹
local MessageType = {
    CACHE_UPDATE = "cache_update",      -- ç¼“å­˜æ›´æ–°
    CACHE_INVALIDATE = "cache_invalidate", -- ç¼“å­˜å¤±æ•ˆ
    CACHE_CLEAR = "cache_clear",        -- ç¼“å­˜æ¸…ç©º
    SYSTEM_UPDATE = "system_update"     -- ç³»ç»Ÿæ›´æ–°
}

-- å‘é€å¹¿æ’­æ¶ˆæ¯
local function broadcastMessage(messageType, cacheType, key, data)
    if not isEnabled then
        return false
    end

    local config = getCacheConfig(cacheType)
    if not config.enableBroadcast then
        return false
    end

    local message = {
        type = messageType,
        cacheType = cacheType,
        key = key,
        data = data,
        serverId = serverId,
        timestamp = os.time()
    }

    local success, error = pcall(function()
        MessagingService:PublishAsync("ShopCacheSync", message)
    end)

    if success then
        stats.broadcasts[cacheType] = (stats.broadcasts[cacheType] or 0) + 1
        print("ğŸ“¡ [CacheManager] å¹¿æ’­æ¶ˆæ¯:", messageType, cacheType, key)
        return true
    else
        warn("âŒ [CacheManager] å¹¿æ’­å¤±è´¥:", error)
        return false
    end
end

-- å¤„ç†æ¥æ”¶åˆ°çš„å¹¿æ’­æ¶ˆæ¯
local function handleBroadcastMessage(message)
    -- å¿½ç•¥æ¥è‡ªè‡ªå·±çš„æ¶ˆæ¯
    if message.serverId == serverId then
        return
    end

    local messageType = message.type
    local cacheType = message.cacheType
    local key = message.key
    local data = message.data

    print("ğŸ“¥ [CacheManager] æ¥æ”¶å¹¿æ’­:", messageType, cacheType, key)

    if messageType == MessageType.CACHE_UPDATE and data then
        -- è¿œç¨‹ç¼“å­˜æ›´æ–°
        local config = getCacheConfig(cacheType)
        CacheManager.set(cacheType, key, data, config.ttl, false) -- ä¸å†æ¬¡å¹¿æ’­
        print("ğŸ”„ [CacheManager] è¿œç¨‹æ›´æ–°ç¼“å­˜:", cacheType, key)

    elseif messageType == MessageType.CACHE_INVALIDATE then
        -- è¿œç¨‹ç¼“å­˜å¤±æ•ˆ
        CacheManager.invalidate(cacheType, key, false) -- ä¸å†æ¬¡å¹¿æ’­
        print("ğŸ—‘ï¸ [CacheManager] è¿œç¨‹å¤±æ•ˆç¼“å­˜:", cacheType, key)

    elseif messageType == MessageType.CACHE_CLEAR then
        -- è¿œç¨‹ç¼“å­˜æ¸…ç©º
        CacheManager.clear(cacheType, false) -- ä¸å†æ¬¡å¹¿æ’­
        print("ğŸ§¹ [CacheManager] è¿œç¨‹æ¸…ç©ºç¼“å­˜:", cacheType)

    elseif messageType == MessageType.SYSTEM_UPDATE then
        -- ç³»ç»Ÿçº§æ›´æ–°ï¼Œå¯ä»¥è§¦å‘ç‰¹å®šçš„å¤„ç†é€»è¾‘
        print("âš¡ [CacheManager] ç³»ç»Ÿæ›´æ–°äº‹ä»¶:", data)
        if data and data.action then
            CacheManager.handleSystemUpdate(data.action, data.params)
        end
    end
end

-- ==============================================
-- æ ¸å¿ƒç¼“å­˜æ“ä½œ
-- ==============================================

-- è®¾ç½®ç¼“å­˜
function CacheManager.set(cacheType, key, value, ttl, shouldBroadcast)
    if not cacheType or not key or value == nil then
        warn("âŒ [CacheManager] æ— æ•ˆçš„ç¼“å­˜å‚æ•°")
        return false
    end

    initializeCacheType(cacheType)
    shouldBroadcast = shouldBroadcast ~= false -- é»˜è®¤ä¸ºtrue

    local config = getCacheConfig(cacheType)
    local actualTtl = ttl or config.ttl
    local entry = createCacheEntry(value, actualTtl)

    -- æ£€æŸ¥ç¼“å­˜å¤§å°é™åˆ¶
    local currentSize = 0
    for _ in pairs(caches[cacheType]) do
        currentSize = currentSize + 1
    end

    if currentSize >= config.maxSize then
        -- ä½¿ç”¨LRUç­–ç•¥æ¸…ç†æœ€æ—§çš„æ¡ç›®
        CacheManager.evictLRU(cacheType, 1)
    end

    caches[cacheType][key] = entry
    stats.sets[cacheType] = stats.sets[cacheType] + 1

    -- å¹¿æ’­æ›´æ–°
    if shouldBroadcast and isEnabled then
        broadcastMessage(MessageType.CACHE_UPDATE, cacheType, key, value)
    end

    print("ğŸ’¾ [CacheManager] è®¾ç½®ç¼“å­˜:", cacheType, key, "TTL:", actualTtl)
    return true
end

-- è·å–ç¼“å­˜
function CacheManager.get(cacheType, key)
    if not cacheType or not key then
        return nil
    end

    initializeCacheType(cacheType)

    local entry = caches[cacheType][key]
    if not entry then
        stats.misses[cacheType] = stats.misses[cacheType] + 1
        return nil
    end

    -- æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if isExpired(entry) then
        caches[cacheType][key] = nil
        stats.misses[cacheType] = stats.misses[cacheType] + 1
        print("â° [CacheManager] ç¼“å­˜å·²è¿‡æœŸ:", cacheType, key)
        return nil
    end

    -- æ›´æ–°è®¿é—®ä¿¡æ¯
    entry.accessCount = entry.accessCount + 1
    entry.lastAccessed = os.time()

    stats.hits[cacheType] = stats.hits[cacheType] + 1
    print("ğŸ“– [CacheManager] ç¼“å­˜å‘½ä¸­:", cacheType, key)
    return entry.value
end

-- ä½¿ç¼“å­˜å¤±æ•ˆ
function CacheManager.invalidate(cacheType, key, shouldBroadcast)
    if not cacheType or not key then
        return false
    end

    initializeCacheType(cacheType)
    shouldBroadcast = shouldBroadcast ~= false -- é»˜è®¤ä¸ºtrue

    local existed = caches[cacheType][key] ~= nil
    caches[cacheType][key] = nil

    if existed then
        stats.invalidations[cacheType] = stats.invalidations[cacheType] + 1

        -- å¹¿æ’­å¤±æ•ˆ
        if shouldBroadcast and isEnabled then
            broadcastMessage(MessageType.CACHE_INVALIDATE, cacheType, key, nil)
        end

        print("ğŸ—‘ï¸ [CacheManager] å¤±æ•ˆç¼“å­˜:", cacheType, key)
    end

    return existed
end

-- æ¸…ç©ºç‰¹å®šç±»å‹çš„ç¼“å­˜
function CacheManager.clear(cacheType, shouldBroadcast)
    if not cacheType then
        return false
    end

    initializeCacheType(cacheType)
    shouldBroadcast = shouldBroadcast ~= false -- é»˜è®¤ä¸ºtrue

    local count = 0
    for key in pairs(caches[cacheType]) do
        count = count + 1
    end

    caches[cacheType] = {}

    -- å¹¿æ’­æ¸…ç©º
    if shouldBroadcast and isEnabled then
        broadcastMessage(MessageType.CACHE_CLEAR, cacheType, nil, nil)
    end

    print("ğŸ§¹ [CacheManager] æ¸…ç©ºç¼“å­˜:", cacheType, "æ¸…ç†æ¡ç›®:", count)
    return true
end

-- æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
function CacheManager.clearAll()
    local totalCount = 0

    for cacheType in pairs(caches) do
        local count = 0
        for key in pairs(caches[cacheType]) do
            count = count + 1
        end
        totalCount = totalCount + count
        caches[cacheType] = {}
    end

    -- é‡ç½®ç»Ÿè®¡
    for cacheType in pairs(stats.hits) do
        stats.hits[cacheType] = 0
        stats.misses[cacheType] = 0
        stats.sets[cacheType] = 0
        stats.invalidations[cacheType] = 0
        stats.broadcasts[cacheType] = 0
    end

    stats.totalMemory = 0

    print("ğŸ§¹ [CacheManager] æ¸…ç©ºæ‰€æœ‰ç¼“å­˜ï¼Œæ¸…ç†æ¡ç›®:", totalCount)
    return totalCount
end

-- ==============================================
-- ç¼“å­˜ç®¡ç†æ“ä½œ
-- ==============================================

-- LRUæ·˜æ±°ç­–ç•¥
function CacheManager.evictLRU(cacheType, count)
    count = count or 1

    if not caches[cacheType] then
        return 0
    end

    local entries = {}
    for key, entry in pairs(caches[cacheType]) do
        table.insert(entries, {key = key, entry = entry})
    end

    -- æŒ‰æœ€åè®¿é—®æ—¶é—´æ’åº
    table.sort(entries, function(a, b)
        return a.entry.lastAccessed < b.entry.lastAccessed
    end)

    local evictedCount = 0
    for i = 1, math.min(count, #entries) do
        local key = entries[i].key
        caches[cacheType][key] = nil
        evictedCount = evictedCount + 1
        print("ğŸ—‘ï¸ [CacheManager] LRUæ·˜æ±°:", cacheType, key)
    end

    return evictedCount
end

-- æ¸…ç†è¿‡æœŸç¼“å­˜
function CacheManager.cleanupExpired()
    local totalCleaned = 0
    local currentTime = os.time()

    for cacheType, cache in pairs(caches) do
        local cleaned = 0
        local keysToRemove = {}

        for key, entry in pairs(cache) do
            if isExpired(entry) then
                table.insert(keysToRemove, key)
            end
        end

        for _, key in ipairs(keysToRemove) do
            cache[key] = nil
            cleaned = cleaned + 1
        end

        if cleaned > 0 then
            print("ğŸ§¹ [CacheManager] æ¸…ç†è¿‡æœŸç¼“å­˜:", cacheType, "æ¸…ç†æ•°é‡:", cleaned)
        end

        totalCleaned = totalCleaned + cleaned
    end

    stats.lastCleanup = currentTime
    updateMemoryStats()

    if totalCleaned > 0 then
        print("âœ… [CacheManager] æ€»è®¡æ¸…ç†è¿‡æœŸç¼“å­˜:", totalCleaned)
    end

    return totalCleaned
end

-- ==============================================
-- ç‰¹æ®Šç¼“å­˜æ“ä½œ
-- ==============================================

-- åˆ·æ–°ç”¨æˆ·ç›¸å…³çš„æ‰€æœ‰ç¼“å­˜
function CacheManager.refreshUserCache(userId)
    local userCacheTypes = {
        CacheType.USER_DATA,
        CacheType.USER_INVENTORY,
        CacheType.MEMBERSHIP,
        CacheType.DAILY_REWARDS
    }

    local clearedCount = 0
    for _, cacheType in ipairs(userCacheTypes) do
        if CacheManager.invalidate(cacheType, userId) then
            clearedCount = clearedCount + 1
        end
    end

    print("ğŸ”„ [CacheManager] åˆ·æ–°ç”¨æˆ·ç¼“å­˜:", userId, "æ¸…ç†é¡¹ç›®:", clearedCount)
    return clearedCount
end

-- åˆ·æ–°å•†åº—ç›¸å…³ç¼“å­˜
function CacheManager.refreshShopCache()
    CacheManager.clear(CacheType.SHOP_ITEMS)

    -- å¹¿æ’­ç³»ç»Ÿæ›´æ–°äº‹ä»¶
    if isEnabled then
        broadcastMessage(MessageType.SYSTEM_UPDATE, "system", "shop_refresh", {
            action = "shop_refresh",
            timestamp = os.time()
        })
    end

    print("ğŸ›’ [CacheManager] åˆ·æ–°å•†åº—ç¼“å­˜")
end

-- å¤„ç†ç³»ç»Ÿæ›´æ–°äº‹ä»¶
function CacheManager.handleSystemUpdate(action, params)
    if action == "shop_refresh" then
        -- å•†åº—åˆ·æ–°ï¼šæ¸…ç©ºç›¸å…³ç¼“å­˜
        CacheManager.clear(CacheType.SHOP_ITEMS, false) -- é¿å…å¾ªç¯å¹¿æ’­
        print("ğŸ›’ [CacheManager] å¤„ç†å•†åº—åˆ·æ–°äº‹ä»¶")

    elseif action == "user_logout" and params and params.userId then
        -- ç”¨æˆ·ç™»å‡ºï¼šæ¸…ç†ç”¨æˆ·ç¼“å­˜
        CacheManager.refreshUserCache(params.userId)
        print("ğŸ‘¤ [CacheManager] å¤„ç†ç”¨æˆ·ç™»å‡ºäº‹ä»¶:", params.userId)

    elseif action == "admin_update" then
        -- ç®¡ç†å‘˜æ›´æ–°ï¼šæ¸…ç©ºç®¡ç†å‘˜æƒé™ç¼“å­˜
        CacheManager.clear(CacheType.ADMIN_PERMISSIONS, false)
        print("ğŸ‘‘ [CacheManager] å¤„ç†ç®¡ç†å‘˜æƒé™æ›´æ–°äº‹ä»¶")

    elseif action == "config_update" then
        -- é…ç½®æ›´æ–°ï¼šæ¸…ç©ºç³»ç»Ÿé…ç½®ç¼“å­˜
        CacheManager.clear(CacheType.SYSTEM_CONFIG, false)
        print("âš™ï¸ [CacheManager] å¤„ç†ç³»ç»Ÿé…ç½®æ›´æ–°äº‹ä»¶")
    end
end

-- ==============================================
-- ç»Ÿè®¡å’Œç›‘æ§
-- ==============================================

-- è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
function CacheManager.getStats()
    updateMemoryStats()

    local detailedStats = {}
    for cacheType in pairs(caches) do
        local cache = caches[cacheType]
        local count = 0
        local expiredCount = 0

        for key, entry in pairs(cache) do
            count = count + 1
            if isExpired(entry) then
                expiredCount = expiredCount + 1
            end
        end

        detailedStats[cacheType] = {
            count = count,
            expired = expiredCount,
            hits = stats.hits[cacheType] or 0,
            misses = stats.misses[cacheType] or 0,
            sets = stats.sets[cacheType] or 0,
            invalidations = stats.invalidations[cacheType] or 0,
            broadcasts = stats.broadcasts[cacheType] or 0,
            hitRate = (stats.hits[cacheType] or 0) / math.max(1, (stats.hits[cacheType] or 0) + (stats.misses[cacheType] or 0))
        }
    end

    return {
        caches = detailedStats,
        totalMemory = stats.totalMemory,
        lastCleanup = stats.lastCleanup,
        serverId = serverId,
        isEnabled = isEnabled
    }
end

-- æ‰“å°ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
function CacheManager.printStats()
    local stats = CacheManager.getStats()

    print("=" .. string.rep("=", 60))
    print("ğŸ“Š ç¼“å­˜ç®¡ç†å™¨ç»Ÿè®¡ä¿¡æ¯")
    print("=" .. string.rep("=", 60))
    print("æœåŠ¡å™¨ID:", stats.serverId)
    print("å¯ç”¨çŠ¶æ€:", stats.isEnabled and "æ˜¯" or "å¦")
    print("æ€»å†…å­˜ä½¿ç”¨:", math.floor(stats.totalMemory / 1024), "KB")
    print("ä¸Šæ¬¡æ¸…ç†:", os.date("%Y-%m-%d %H:%M:%S", stats.lastCleanup))
    print("")

    for cacheType, cacheStat in pairs(stats.caches) do
        print(string.format("ğŸ“¦ %s:", cacheType))
        print(string.format("  æ¡ç›®æ•°: %d (è¿‡æœŸ: %d)", cacheStat.count, cacheStat.expired))
        print(string.format("  å‘½ä¸­ç‡: %.1f%% (%d/%d)", cacheStat.hitRate * 100, cacheStat.hits, cacheStat.hits + cacheStat.misses))
        print(string.format("  æ“ä½œæ•°: è®¾ç½®=%d, å¤±æ•ˆ=%d, å¹¿æ’­=%d", cacheStat.sets, cacheStat.invalidations, cacheStat.broadcasts))
        print("")
    end
    print("=" .. string.rep("=", 60))
end

-- ==============================================
-- æ¨¡å—åˆå§‹åŒ–å’Œæ¸…ç†
-- ==============================================

-- åˆå§‹åŒ–æ¨¡å—
function CacheManager.initialize()
    print("ğŸš€ [CacheManager] åˆå§‹åŒ–ç¼“å­˜ç®¡ç†å™¨...")

    -- è®¾ç½®MessagingServiceç›‘å¬å™¨
    if isEnabled then
        local success, connection = pcall(function()
            return MessagingService:SubscribeAsync("ShopCacheSync", function(message)
                handleBroadcastMessage(message.Data)
            end)
        end)

        if success then
            print("âœ… [CacheManager] MessagingService ç›‘å¬å™¨å·²å¯åŠ¨")
        else
            warn("âŒ [CacheManager] MessagingService å¯åŠ¨å¤±è´¥:", connection)
            isEnabled = false
        end
    else
        print("âš ï¸ [CacheManager] Studioç¯å¢ƒï¼Œè·³è¿‡MessagingServiceåˆå§‹åŒ–")
    end

    -- å¯åŠ¨æ¸…ç†ä»»åŠ¡
    spawn(function()
        while true do
            wait(DEFAULT_CONFIG.cleanupInterval)
            CacheManager.cleanupExpired()
        end
    end)

    -- å¯åŠ¨ç»Ÿè®¡ä»»åŠ¡ï¼ˆæ¯5åˆ†é’Ÿæ‰“å°ä¸€æ¬¡ç»Ÿè®¡ï¼‰
    if EnvironmentManager.isStudio() then
        spawn(function()
            while true do
                wait(300) -- 5åˆ†é’Ÿ
                CacheManager.printStats()
            end
        end)
    end

    print("âœ… [CacheManager] ç¼“å­˜ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ")
end

-- å…³é—­æ¨¡å—
function CacheManager.shutdown()
    print("ğŸ›‘ [CacheManager] å…³é—­ç¼“å­˜ç®¡ç†å™¨...")

    -- æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
    CacheManager.clearAll()

    print("âœ… [CacheManager] ç¼“å­˜ç®¡ç†å™¨å·²å…³é—­")
end

-- ==============================================
-- å¯¼å‡ºæ¥å£
-- ==============================================

-- å¯¼å‡ºç¼“å­˜ç±»å‹å¸¸é‡
CacheManager.Types = CacheType

-- å¯¼å‡ºæ¶ˆæ¯ç±»å‹å¸¸é‡
CacheManager.MessageType = MessageType

-- å¯åŠ¨åˆå§‹åŒ–
spawn(function()
    wait(1) -- ç­‰å¾…å…¶ä»–æœåŠ¡å¯åŠ¨
    CacheManager.initialize()
end)

return CacheManager
