-- ç®¡ç†å‘˜æ•°æ®æœåŠ¡ - æ›¿æ¢ adminSQLOperations.js
-- å¤„ç†æ‰€æœ‰ç®¡ç†å‘˜ç›¸å…³çš„æ•°æ®æ“ä½œ

local DataStoreManager = require(game:GetService("ServerScriptService").Server.datastoreservice.DataStoreManager)
local UserDataService = require(game:GetService("ServerScriptService").Server.datastoreservice.UserDataService)
local HttpService = game:GetService("HttpService")

local AdminDataService = {}

-- ==============================================
-- ç”¨æˆ·ç®¡ç†åŠŸèƒ½
-- ==============================================

-- è·å–æ‰€æœ‰ç”¨æˆ·ï¼ˆå¸¦åˆ†é¡µï¼‰
function AdminDataService.getUsersWithPagination(options)
    options = options or {}
    local limit = math.min(1000, math.max(1, options.limit or 100))
    local offset = math.max(0, options.offset or 0)
    local status = options.status
    local search = options.search
    local sortBy = options.sortBy or "created_at"
    local sortOrder = options.sortOrder or "DESC"

    -- è·å–æ‰€æœ‰ç”¨æˆ·æ•°æ®ï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨ ListDataStoresAsyncï¼‰
    local allUsersData = AdminDataService.getAllUsersData()
    local filteredUsers = {}

    -- ç­›é€‰ç”¨æˆ·
    for userId, userData in pairs(allUsersData) do
        local shouldInclude = true

        -- çŠ¶æ€ç­›é€‰
        if status and userData.status ~= status then
            shouldInclude = false
        end

        -- æœç´¢ç­›é€‰
        if search and shouldInclude then
            local searchLower = string.lower(search)
            local usernameLower = string.lower(userData.username or "")
            local displayNameLower = string.lower(userData.displayName or "")

            if not (string.find(usernameLower, searchLower) or string.find(displayNameLower, searchLower)) then
                shouldInclude = false
            end
        end

        if shouldInclude then
            -- è·å–ç”¨æˆ·ç»Ÿè®¡
            local userStats = AdminDataService.getUserStats(userId)
            local membershipStatus = UserDataService.getMembershipStatus(userId)

            table.insert(filteredUsers, {
                id = userData.userId,
                username = userData.username,
                display_name = userData.displayName,
                coins = userData.coins,
                status = userData.status,
                is_admin = userData.isAdmin,
                created_at = userData.createdAt,
                updated_at = userData.updatedAt,
                last_login = userData.lastLogin,

                -- ç»Ÿè®¡æ•°æ®
                buy_count = userStats.buy_count,
                sell_count = userStats.sell_count,
                total_spent = userStats.total_spent,
                total_earned = userStats.total_earned,

                -- ä¼šå‘˜çŠ¶æ€
                membership_status = membershipStatus.isValid and "active" or (membershipStatus.hasMembership and "expired" or "none"),
                membership_end_date = membershipStatus.endDate,
                end_date = membershipStatus.endDate,
                days_remaining = membershipStatus.daysRemaining,
                daily_reward_coins = membershipStatus.dailyReward
            })
        end
    end

    -- æ’åº
    table.sort(filteredUsers, function(a, b)
        local aVal = a[sortBy] or 0
        local bVal = b[sortBy] or 0

        if sortOrder == "ASC" then
            return aVal < bVal
        else
            return aVal > bVal
        end
    end)

    -- åˆ†é¡µ
    local paginatedUsers = {}
    local startIndex = offset + 1
    local endIndex = math.min(startIndex + limit - 1, #filteredUsers)

    for i = startIndex, endIndex do
        table.insert(paginatedUsers, filteredUsers[i])
    end

    return paginatedUsers
end

-- è·å–ç”¨æˆ·æ€»æ•°
function AdminDataService.getUserCount(status)
    local allUsersData = AdminDataService.getAllUsersData()
    local count = 0

    for userId, userData in pairs(allUsersData) do
        if not status or userData.status == status then
            count = count + 1
        end
    end

    return count
end

-- è·å–ç”¨æˆ·ç»Ÿè®¡æ•°æ®
function AdminDataService.getUserStats(userId)
    userId = tostring(userId)

    local userTransactionsKey = "user_transactions_" .. userId
    local transactions = DataStoreManager.safeGetAsync("TRANSACTIONS", userTransactionsKey, {})

    local stats = {
        buy_count = 0,
        sell_count = 0,
        total_spent = 0,
        total_earned = 0
    }

    for _, transaction in ipairs(transactions) do
        if transaction.type == "buy" then
            stats.buy_count = stats.buy_count + 1
            stats.total_spent = stats.total_spent + transaction.totalAmount
        elseif transaction.type == "sell" then
            stats.sell_count = stats.sell_count + 1
            stats.total_earned = stats.total_earned + transaction.totalAmount
        end
    end

    return stats
end

-- æ‰¹é‡è·å–å¤šä¸ªç”¨æˆ·çš„ç»Ÿè®¡æ•°æ®
function AdminDataService.getBatchUserStats(userIds)
    if not userIds or #userIds == 0 then
        return {}
    end

    local statsMap = {}

    for _, userId in ipairs(userIds) do
        local userStats = AdminDataService.getUserStats(userId)
        statsMap[userId] = userStats
    end

    return statsMap
end

-- è·å–ç”¨æˆ·è¯¦ç»†ä¿¡æ¯
function AdminDataService.getUserDetails(userId)
    return UserDataService.getUserDetails(userId)
end

-- æ›´æ–°ç”¨æˆ·é‡‘å¸
function AdminDataService.updateUserCoins(userId, coins, reason, adminUserId)
    userId = tostring(userId)
    adminUserId = tostring(adminUserId)

    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        local coinsBefore = currentData.coins
        local coinsAfter = coins
        local coinsDifference = coinsAfter - coinsBefore

        currentData.coins = coins
        currentData.updatedAt = os.time()

        return currentData, coinsBefore, coinsAfter, coinsDifference
    end)

    if success and result then
        local coinsBefore, coinsAfter, coinsDifference = result[2], result[3], result[4]

        -- è®°å½•äº¤æ˜“
        UserDataService.addTransactionRecord(
            userId, "admin", nil, 1, coinsDifference, coinsDifference,
            coinsBefore, coinsAfter, reason or "ç®¡ç†å‘˜è°ƒæ•´é‡‘å¸"
        )

        -- è®°å½•ç®¡ç†å‘˜æ“ä½œæ—¥å¿—
        AdminDataService.logAdminAction(adminUserId, "update_coins", {
            target_user_id = userId,
            coins_before = coinsBefore,
            coins_after = coinsAfter,
            reason = reason
        })

        return true
    end

    return false
end

-- æ›´æ–°ç”¨æˆ·çŠ¶æ€
function AdminDataService.updateUserStatus(userId, status)
    userId = tostring(userId)

    local success = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        currentData.status = status
        currentData.updatedAt = os.time()

        return currentData
    end)

    return success
end

-- æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
function AdminDataService.checkUserExists(userIdOrUsername, isUserId)
    if isUserId == nil then isUserId = true end

    if isUserId then
        local userData = DataStoreManager.safeGetAsync("USERS", tostring(userIdOrUsername), nil)
        if userData then
            return {
                id = userData.userId,
                username = userData.username,
                display_name = userData.displayName,
                is_admin = userData.isAdmin,
                status = userData.status,
                coins = userData.coins,
                created_at = userData.createdAt
            }
        end
    else
        -- é€šè¿‡ç”¨æˆ·åæŸ¥æ‰¾éœ€è¦éå†æ‰€æœ‰ç”¨æˆ·ï¼ˆåœ¨ç”Ÿäº§ç¯å¢ƒä¸­å¯èƒ½éœ€è¦ä¼˜åŒ–ï¼‰
        local allUsersData = AdminDataService.getAllUsersData()
        for userId, userData in pairs(allUsersData) do
            if userData.username == userIdOrUsername then
                return {
                    id = userData.userId,
                    username = userData.username,
                    display_name = userData.displayName,
                    is_admin = userData.isAdmin,
                    status = userData.status,
                    coins = userData.coins,
                    created_at = userData.createdAt
                }
            end
        end
    end

    return nil
end

-- é€šè¿‡ç”¨æˆ·åæŸ¥æ‰¾ç”¨æˆ·
function AdminDataService.getUserByUsername(username)
    return AdminDataService.checkUserExists(username, false)
end

-- ==============================================
-- ç®¡ç†å‘˜æƒé™ç®¡ç†
-- ==============================================

-- è·å–ç®¡ç†å‘˜åˆ—è¡¨
function AdminDataService.getAdminList()
    local allUsersData = AdminDataService.getAllUsersData()
    local adminList = {}

    for userId, userData in pairs(allUsersData) do
        if userData.isAdmin then
            table.insert(adminList, {
                id = userData.userId,
                username = userData.username,
                display_name = userData.displayName,
                created_at = userData.createdAt,
                last_login = userData.lastLogin
            })
        end
    end

    -- æŒ‰åˆ›å»ºæ—¶é—´é™åºæ’åº
    table.sort(adminList, function(a, b)
        return a.created_at > b.created_at
    end)

    return adminList
end

-- æ·»åŠ ç®¡ç†å‘˜
function AdminDataService.addAdmin(userData)
    local userId = tostring(userData.user_id)
    local username = userData.username

    -- åˆ›å»ºæˆ–æ›´æ–°ç”¨æˆ·è®°å½•
    local success = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if currentData then
            -- ç”¨æˆ·å­˜åœ¨ï¼Œæå‡ä¸ºç®¡ç†å‘˜
            currentData.isAdmin = true
            currentData.updatedAt = os.time()
            return currentData
        else
            -- åˆ›å»ºæ–°ç”¨æˆ·
            local newUserData = DataStoreManager.getDefaultUserData()
            newUserData.userId = userId
            newUserData.username = username
            newUserData.displayName = username
            newUserData.isAdmin = true
            return newUserData
        end
    end)

    if success then
        return {success = true, message = "ç®¡ç†å‘˜æ·»åŠ æˆåŠŸ"}
    else
        return {success = false, message = "ç®¡ç†å‘˜æ·»åŠ å¤±è´¥"}
    end
end

-- æå‡ç”¨æˆ·ä¸ºç®¡ç†å‘˜
function AdminDataService.promoteToAdmin(userId)
    userId = tostring(userId)

    local success = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        currentData.isAdmin = true
        currentData.updatedAt = os.time()

        return currentData
    end)

    if success then
        return {success = true, message = "ç”¨æˆ·å·²æå‡ä¸ºç®¡ç†å‘˜"}
    else
        return {success = false, message = "æå‡ç®¡ç†å‘˜å¤±è´¥"}
    end
end

-- ç§»é™¤ç®¡ç†å‘˜æƒé™
function AdminDataService.removeAdmin(userId)
    userId = tostring(userId)

    local success = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç®¡ç†å‘˜ä¸å­˜åœ¨")
        end

        currentData.isAdmin = false
        currentData.updatedAt = os.time()

        return currentData
    end)

    if success then
        return {success = true, message = "ç®¡ç†å‘˜æƒé™å·²ç§»é™¤"}
    else
        return {success = false, message = "ç§»é™¤ç®¡ç†å‘˜æƒé™å¤±è´¥"}
    end
end

-- ==============================================
-- ç³»ç»Ÿç®¡ç†åŠŸèƒ½
-- ==============================================

-- è·å–å®Œæ•´ç³»ç»Ÿç»Ÿè®¡
function AdminDataService.getCompleteSystemStats()
    local allUsersData = AdminDataService.getAllUsersData()
    local allItems = DataStoreManager.getAllItems()

    local stats = {}

    -- ç”¨æˆ·ç»Ÿè®¡
    local userStats = {
        total_users = 0,
        active_users = 0,
        banned_users = 0,
        admin_users = 0,
        active_last_week = 0,
        new_users_30_days = 0
    }

    local currentTime = os.time()
    local weekAgo = currentTime - (7 * 24 * 60 * 60)
    local monthAgo = currentTime - (30 * 24 * 60 * 60)

    for userId, userData in pairs(allUsersData) do
        userStats.total_users = userStats.total_users + 1

        if userData.status == "active" then
            userStats.active_users = userStats.active_users + 1
        elseif userData.status == "banned" then
            userStats.banned_users = userStats.banned_users + 1
        end

        if userData.isAdmin then
            userStats.admin_users = userStats.admin_users + 1
        end

        if userData.lastLogin and userData.lastLogin >= weekAgo then
            userStats.active_last_week = userStats.active_last_week + 1
        end

        if userData.createdAt and userData.createdAt >= monthAgo then
            userStats.new_users_30_days = userStats.new_users_30_days + 1
        end
    end

    stats.users = userStats

    -- äº¤æ˜“ç»Ÿè®¡ï¼ˆéœ€è¦éå†æ‰€æœ‰ç”¨æˆ·çš„äº¤æ˜“è®°å½•ï¼‰
    local transactionStats = {
        total_transactions = 0,
        total_buys = 0,
        total_sells = 0,
        total_spent = 0,
        total_earned = 0,
        transactions_24h = 0,
        transactions_7d = 0
    }

    local dayAgo = currentTime - (24 * 60 * 60)
    local sevenDaysAgo = currentTime - (7 * 24 * 60 * 60)

    for userId, userData in pairs(allUsersData) do
        local userTransactionsKey = "user_transactions_" .. userId
        local transactions = DataStoreManager.safeGetAsync("TRANSACTIONS", userTransactionsKey, {})

        for _, transaction in ipairs(transactions) do
            transactionStats.total_transactions = transactionStats.total_transactions + 1

            if transaction.type == "buy" then
                transactionStats.total_buys = transactionStats.total_buys + 1
                transactionStats.total_spent = transactionStats.total_spent + transaction.totalAmount
            elseif transaction.type == "sell" then
                transactionStats.total_sells = transactionStats.total_sells + 1
                transactionStats.total_earned = transactionStats.total_earned + transaction.totalAmount
            end

            if transaction.createdAt >= dayAgo then
                transactionStats.transactions_24h = transactionStats.transactions_24h + 1
            end

            if transaction.createdAt >= sevenDaysAgo then
                transactionStats.transactions_7d = transactionStats.transactions_7d + 1
            end
        end
    end

    stats.transactions = transactionStats

    -- å•†å“ç»Ÿè®¡
    local itemStats = {
        total_items = 0,
        active_items = 0,
        out_of_stock_items = 0,
        average_price = 0
    }

    local totalPrice = 0
    for itemId, itemData in pairs(allItems) do
        itemStats.total_items = itemStats.total_items + 1
        totalPrice = totalPrice + itemData.price

        if itemData.isActive then
            itemStats.active_items = itemStats.active_items + 1
        end

        if itemData.currentStock == 0 then
            itemStats.out_of_stock_items = itemStats.out_of_stock_items + 1
        end
    end

    if itemStats.total_items > 0 then
        itemStats.average_price = totalPrice / itemStats.total_items
    end

    stats.items = itemStats

    -- ä¼šå‘˜ç»Ÿè®¡
    local membershipStats = {
        total_members = 0,
        active_members = 0,
        expired_members = 0
    }

    for userId, userData in pairs(allUsersData) do
        if userData.membership and userData.membership.membershipId then
            membershipStats.total_members = membershipStats.total_members + 1

            if userData.membership.isActive and userData.membership.endDate > currentTime then
                membershipStats.active_members = membershipStats.active_members + 1
            else
                membershipStats.expired_members = membershipStats.expired_members + 1
            end
        end
    end

    stats.membership = membershipStats

    return stats
end

-- ==============================================
-- å•†å“ç®¡ç†åŠŸèƒ½
-- ==============================================

-- æ›´æ–°å•†å“åº“å­˜
function AdminDataService.updateItemStock(itemId, stock)
    local success = DataStoreManager.safeUpdateAsync("ITEMS", "all_items", function(currentData)
        local items = currentData or {}
        if items[itemId] then
            items[itemId].currentStock = stock
            items[itemId].updatedAt = os.time()
        end
        return items
    end)

    return success
end

-- æ›´æ–°å•†å“çŠ¶æ€
function AdminDataService.updateItemStatus(itemId, active)
    local success = DataStoreManager.safeUpdateAsync("ITEMS", "all_items", function(currentData)
        local items = currentData or {}
        if items[itemId] then
            items[itemId].isActive = active
            items[itemId].updatedAt = os.time()
        end
        return items
    end)

    return success
end

-- è·å–å•†å“åˆ—è¡¨
function AdminDataService.getItemsList(page, limit, category, isActive)
    page = page or 1
    limit = limit or 20
    local offset = (page - 1) * limit

    local allItems = DataStoreManager.getAllItems()
    local filteredItems = {}

    for itemId, itemData in pairs(allItems) do
        local shouldInclude = true

        -- çŠ¶æ€ç­›é€‰
        if isActive ~= nil and itemData.isActive ~= isActive then
            shouldInclude = false
        end

        -- åˆ†ç±»ç­›é€‰
        if category and category ~= "" and itemData.category ~= category then
            shouldInclude = false
        end

        if shouldInclude then
            table.insert(filteredItems, {
                id = itemData.id,
                name = itemData.name,
                description = itemData.description,
                price = itemData.price,
                sell_price = itemData.sellPrice,
                max_quantity = itemData.maxQuantity,
                current_stock = itemData.currentStock,
                daily_purchase_limit = itemData.dailyPurchaseLimit,
                can_sell = itemData.canSell,
                category = itemData.category,
                image_url = itemData.imageUrl,
                is_active = itemData.isActive,
                sort_order = itemData.sortOrder,
                created_at = itemData.createdAt,
                updated_at = itemData.updatedAt
            })
        end
    end

    -- æ’åºï¼šä¼šå‘˜å•†å“åœ¨å‰ï¼Œç„¶åæŒ‰sortOrderé™åº
    table.sort(filteredItems, function(a, b)
        if a.category == "membership" and b.category ~= "membership" then
            return true
        elseif a.category ~= "membership" and b.category == "membership" then
            return false
        else
            return (a.sort_order or 0) > (b.sort_order or 0)
        end
    end)

    -- åˆ†é¡µ
    local paginatedItems = {}
    local startIndex = offset + 1
    local endIndex = math.min(startIndex + limit - 1, #filteredItems)

    for i = startIndex, endIndex do
        table.insert(paginatedItems, filteredItems[i])
    end

    return {
        items = paginatedItems,
        total = #filteredItems,
        page = page,
        limit = limit,
        totalPages = math.ceil(#filteredItems / limit)
    }
end

-- æ ¹æ®IDè·å–å•†å“è¯¦æƒ…
function AdminDataService.getItemById(itemId)
    local itemData = DataStoreManager.getItem(itemId)

    if itemData then
        return {
            id = itemData.id,
            name = itemData.name,
            description = itemData.description,
            price = itemData.price,
            sell_price = itemData.sellPrice,
            max_quantity = itemData.maxQuantity,
            current_stock = itemData.currentStock,
            daily_purchase_limit = itemData.dailyPurchaseLimit,
            can_sell = itemData.canSell,
            category = itemData.category,
            image_url = itemData.imageUrl,
            is_active = itemData.isActive,
            sort_order = itemData.sortOrder,
            created_at = itemData.createdAt,
            updated_at = itemData.updatedAt
        }
    end

    return nil
end

-- è·å–æ‰€æœ‰å•†å“åˆ†ç±»
function AdminDataService.getItemCategories()
    local allItems = DataStoreManager.getAllItems()
    local categories = {}
    local categorySet = {}

    for itemId, itemData in pairs(allItems) do
        if itemData.isActive and not categorySet[itemData.category] then
            categorySet[itemData.category] = true
            table.insert(categories, itemData.category)
        end
    end

    table.sort(categories)

    return categories
end

-- ==============================================
-- ä¼šå‘˜ç®¡ç†åŠŸèƒ½
-- ==============================================

-- è·å–ä¼šå‘˜åˆ—è¡¨
function AdminDataService.getMembersList(page, limit, status)
    page = page or 1
    limit = limit or 20
    local offset = (page - 1) * limit

    local allUsersData = AdminDataService.getAllUsersData()
    local members = {}

    for userId, userData in pairs(allUsersData) do
        if userData.membership and userData.membership.membershipId then
            local membershipStatus = UserDataService.getMembershipStatus(userId)

            -- çŠ¶æ€ç­›é€‰
            local shouldInclude = true
            if status == "active" and not membershipStatus.isValid then
                shouldInclude = false
            elseif status == "expired" and membershipStatus.isValid then
                shouldInclude = false
            end

            if shouldInclude then
                table.insert(members, {
                    user_id = userData.userId,
                    username = userData.username,
                    display_name = userData.displayName,
                    membership_id = userData.membership.membershipId,
                    start_date = userData.membership.startDate and os.date("%Y-%m-%d", userData.membership.startDate) or nil,
                    end_date = userData.membership.endDate and os.date("%Y-%m-%d", userData.membership.endDate) or nil,
                    daily_reward_coins = userData.membership.dailyReward,
                    is_active = userData.membership.isActive,
                    created_at = userData.membership.createdAt,
                    updated_at = userData.updatedAt,
                    status = membershipStatus.isValid and "active" or "expired"
                })
            end
        end
    end

    -- æŒ‰åˆ›å»ºæ—¶é—´é™åºæ’åº
    table.sort(members, function(a, b)
        return (a.created_at or 0) > (b.created_at or 0)
    end)

    -- åˆ†é¡µ
    local paginatedMembers = {}
    local startIndex = offset + 1
    local endIndex = math.min(startIndex + limit - 1, #members)

    for i = startIndex, endIndex do
        table.insert(paginatedMembers, members[i])
    end

    return {
        members = paginatedMembers,
        pagination = {
            page = page,
            limit = limit,
            total = #members,
            totalPages = math.ceil(#members / limit)
        }
    }
end

-- è·å–æ‰€æœ‰ç”¨æˆ·åŠå…¶ä¼šå‘˜çŠ¶æ€
function AdminDataService.getAllUsersWithMembershipStatus(page, limit, status)
    page = page or 1
    limit = limit or 20
    local offset = (page - 1) * limit

    local allUsersData = AdminDataService.getAllUsersData()
    local users = {}

    for userId, userData in pairs(allUsersData) do
        local membershipStatus = UserDataService.getMembershipStatus(userId)

        -- çŠ¶æ€ç­›é€‰
        local shouldInclude = true
        if status == "member" and not membershipStatus.isValid then
            shouldInclude = false
        elseif status == "expired" and (not membershipStatus.hasMembership or membershipStatus.isValid) then
            shouldInclude = false
        elseif status == "non_member" and membershipStatus.hasMembership then
            shouldInclude = false
        end

        if shouldInclude then
            table.insert(users, {
                user_id = userData.userId,
                username = userData.username,
                display_name = userData.displayName,
                coins = userData.coins,
                user_status = userData.status,
                is_admin = userData.isAdmin,
                user_created_at = userData.createdAt,

                membership_id = membershipStatus.membershipId,
                start_date = membershipStatus.startDate,
                end_date = membershipStatus.endDate,
                daily_reward_coins = membershipStatus.dailyReward,
                membership_active = membershipStatus.isActive,
                membership_created_at = userData.membership and userData.membership.createdAt or nil,

                membership_status = membershipStatus.isValid and "active" or (membershipStatus.hasMembership and "expired" or "none"),
                days_remaining = membershipStatus.daysRemaining
            })
        end
    end

    -- æŒ‰ç”¨æˆ·åˆ›å»ºæ—¶é—´é™åºæ’åº
    table.sort(users, function(a, b)
        return (a.user_created_at or 0) > (b.user_created_at or 0)
    end)

    -- åˆ†é¡µ
    local paginatedUsers = {}
    local startIndex = offset + 1
    local endIndex = math.min(startIndex + limit - 1, #users)

    for i = startIndex, endIndex do
        table.insert(paginatedUsers, users[i])
    end

    return {
        users = paginatedUsers,
        pagination = {
            page = page,
            limit = limit,
            total = #users,
            totalPages = math.ceil(#users / limit)
        }
    }
end

-- è´­ä¹°ä¼šå‘˜
function AdminDataService.buyMembership(userId, durationDays, dailyReward)
    userId = tostring(userId)
    durationDays = durationDays or 30
    dailyReward = dailyReward or 100

    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        -- ç¡®ä¿membershipå­—æ®µå­˜åœ¨
        if not currentData.membership then
            currentData.membership = {
                isActive = false,
                membershipId = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 100
            }
        end

        local now = os.time()
        local startDate = now
        local endDate = now + (durationDays * 24 * 60 * 60)

        -- å¦‚æœæœ‰ç°æœ‰ä¼šå‘˜ï¼Œä»ç»“æŸæ—¥æœŸå¼€å§‹å»¶æœŸ
        if currentData.membership.isActive and currentData.membership.endDate and currentData.membership.endDate > now then
            startDate = currentData.membership.endDate
            endDate = startDate + (durationDays * 24 * 60 * 60)
        end

        currentData.membership = {
            isActive = true,
            membershipId = HttpService:GenerateGUID(false),
            startDate = startDate,
            endDate = endDate,
            dailyReward = dailyReward,
            createdAt = now
        }

        currentData.updatedAt = now

        return currentData
    end)

    if success and result then
        -- æ¸…é™¤ä¼šå‘˜çŠ¶æ€ç¼“å­˜ç¡®ä¿ä¸‹æ¬¡è·å–æœ€æ–°æ•°æ®
        local UserDataService = require(game:GetService("ServerScriptService").Server.datastoreservice:WaitForChild("UserDataService"))
        if UserDataService.clearMembershipCache then
            UserDataService.clearMembershipCache(userId)
        end

        return {
            membershipId = result.membership.membershipId,
            startDate = os.date("%Y-%m-%d", result.membership.startDate),
            endDate = os.date("%Y-%m-%d", result.membership.endDate),
            durationDays = durationDays,
            dailyReward = dailyReward
        }
    end

    return nil
end

-- å–æ¶ˆä¼šå‘˜
function AdminDataService.cancelMembership(userId)
    userId = tostring(userId)
    local today = os.date("%Y-%m-%d")

    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        -- ç¡®ä¿membershipå­—æ®µå­˜åœ¨
        if not currentData.membership then
            error("ç”¨æˆ·æ²¡æœ‰ä¼šå‘˜è®°å½•")
        end

        if not currentData.membership.isActive then
            error("ç”¨æˆ·æ²¡æœ‰æ´»è·ƒçš„ä¼šå‘˜è®°å½•")
        end

        currentData.membership.endDate = os.time() -- è®¾ç½®ä¸ºå½“å‰æ—¶é—´ï¼Œç«‹å³è¿‡æœŸ
        currentData.membership.isActive = false
        currentData.updatedAt = os.time()

        return currentData
    end)

    if success then
        -- æ¸…é™¤ä¼šå‘˜çŠ¶æ€ç¼“å­˜ç¡®ä¿ä¸‹æ¬¡è·å–æœ€æ–°æ•°æ®
        local UserDataService = require(game:GetService("ServerScriptService").Server.datastoreservice:WaitForChild("UserDataService"))
        if UserDataService.clearMembershipCache then
            UserDataService.clearMembershipCache(userId)
        end

        return {
            success = true,
            message = "ä¼šå‘˜å·²å–æ¶ˆ",
            endDate = today
        }
    else
        return {
            success = false,
            message = "å–æ¶ˆä¼šå‘˜å¤±è´¥"
        }
    end
end

-- å»¶é•¿ä¼šå‘˜
function AdminDataService.extendMembership(userId, days)
    userId = tostring(userId)

    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        -- ç¡®ä¿membershipå­—æ®µå­˜åœ¨
        if not currentData.membership then
            currentData.membership = {
                isActive = false,
                membershipId = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 100
            }
        end

        -- å¦‚æœæ²¡æœ‰æ´»è·ƒä¼šå‘˜ï¼Œåˆ›å»ºæ–°ä¼šå‘˜
        if not currentData.membership.isActive then
            local now = os.time()
            currentData.membership = {
                isActive = true,
                membershipId = HttpService:GenerateGUID(false),
                startDate = now,
                endDate = now + (days * 24 * 60 * 60),
                dailyReward = currentData.membership.dailyReward or 100,
                createdAt = now
            }
            currentData.updatedAt = now
            return currentData, nil, currentData.membership.endDate
        end

        local oldEndDate = currentData.membership.endDate
        local newEndDate = oldEndDate + (days * 24 * 60 * 60)

        currentData.membership.endDate = newEndDate
        currentData.updatedAt = os.time()

        return currentData, oldEndDate, newEndDate
    end)

    if success and result then
        local oldEndDate, newEndDate = result[2], result[3]

        -- å»¶é•¿ä¼šå‘˜åç«‹å³å‘é€å½“æ—¥å¥–åŠ±
        local UserDataService = require(game:GetService("ServerScriptService").Server.datastoreservice:WaitForChild("UserDataService"))
        local immediateReward = UserDataService.claimTodayMembershipReward(userId)
        if immediateReward and immediateReward.success then
            print("ğŸ [extendMembership] å·²ä¸ºç”¨æˆ·", userId, "å‘é€å½“æ—¥ä¼šå‘˜å¥–åŠ±:", immediateReward.totalRewards)
        end

        return {
            success = true,
            oldEndDate = os.date("%Y-%m-%d", oldEndDate),
            newEndDate = os.date("%Y-%m-%d", newEndDate),
            extendedDays = days,
            immediateReward = immediateReward
        }
    else
        return {
            success = false,
            message = "å»¶é•¿ä¼šå‘˜å¤±è´¥"
        }
    end
end

-- è®¾ç½®ä¼šå‘˜ç»å¯¹å¤©æ•°ï¼ˆä¸å»¶é•¿ä¼šå‘˜ä¸åŒï¼Œè¿™æ˜¯è®¾ç½®æ€»å¤©æ•°ï¼‰
function AdminDataService.setMembershipDays(userId, days)
    userId = tostring(userId)
    days = tonumber(days) or 0

    print("ğŸ”§ [setMembershipDays] å¼€å§‹å¤„ç† - ç”¨æˆ·ID:", userId, "å¤©æ•°:", days)

    if days < 0 then
        print("âŒ [setMembershipDays] å¤©æ•°éªŒè¯å¤±è´¥:", days)
        return {
            success = false,
            message = "å¤©æ•°ä¸èƒ½ä¸ºè´Ÿæ•°"
        }
    end

    print("ğŸ”§ [setMembershipDays] å¼€å§‹æ•°æ®å­˜å‚¨æ“ä½œ...")
    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            print("âŒ [setMembershipDays] ç”¨æˆ·æ•°æ®ä¸å­˜åœ¨:", userId)
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end
        print("âœ… [setMembershipDays] æ‰¾åˆ°ç”¨æˆ·æ•°æ®ï¼Œç»§ç»­å¤„ç†...")

        local now = os.time()

        -- ç¡®ä¿membershipå­—æ®µå­˜åœ¨
        if not currentData.membership then
            currentData.membership = {
                isActive = false,
                membershipId = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 100
            }
        end

        local oldEndDate = currentData.membership.endDate
        local oldDaysRemaining = 0

        -- è®¡ç®—åŸæœ‰å‰©ä½™å¤©æ•°
        if oldEndDate and oldEndDate > now then
            oldDaysRemaining = math.ceil((oldEndDate - now) / (24 * 60 * 60))
        end

        if days == 0 then
            -- è®¾ç½®ä¸º0å¤©ç­‰äºå–æ¶ˆä¼šå‘˜
            currentData.membership.isActive = false
            currentData.membership.endDate = now
            currentData.updatedAt = now

            return currentData, oldDaysRemaining, 0, false
        else
            -- è®¾ç½®æ–°çš„ä¼šå‘˜å¤©æ•°
            local newEndDate = now + (days * 24 * 60 * 60)

            currentData.membership.isActive = true
            if not currentData.membership.membershipId then
                currentData.membership.membershipId = HttpService:GenerateGUID(false)
            end
            if not currentData.membership.startDate then
                currentData.membership.startDate = now
            end
            currentData.membership.endDate = newEndDate
            currentData.updatedAt = now

            return currentData, oldDaysRemaining, days, true
        end
    end)

    if success and result then
        local oldDaysRemaining, newDays, isActive = result[2], result[3], result[4]

        -- ç¡®ä¿ newDays ä¸ä¸º nil
        newDays = newDays or days or 0
        oldDaysRemaining = oldDaysRemaining or 0
        isActive = isActive ~= nil and isActive or false

        print("âœ… [setMembershipDays] æ•°æ®å­˜å‚¨æˆåŠŸ - åŸå¤©æ•°:", oldDaysRemaining, "æ–°å¤©æ•°:", newDays, "æ¿€æ´»çŠ¶æ€:", isActive)

        -- æ¸…é™¤ä¼šå‘˜çŠ¶æ€ç¼“å­˜ç¡®ä¿ä¸‹æ¬¡è·å–æœ€æ–°æ•°æ®
        local UserDataService = require(game:GetService("ServerScriptService").Server.datastoreservice:WaitForChild("UserDataService"))
        if UserDataService.clearMembershipCache then
            UserDataService.clearMembershipCache(userId)
            print("âœ… [setMembershipDays] ç¼“å­˜å·²æ¸…é™¤")
        end

        -- å¦‚æœæ˜¯æ¿€æ´»ä¼šå‘˜ï¼ˆå¤©æ•°å¤§äº0ï¼‰ï¼Œç«‹å³å‘é€å½“æ—¥å¥–åŠ±
        local immediateReward = nil
        if isActive and newDays > 0 then
            immediateReward = UserDataService.claimTodayMembershipReward(userId)
            if immediateReward and immediateReward.success then
                print("ğŸ [setMembershipDays] å·²ä¸ºç”¨æˆ·", userId, "å‘é€å½“æ—¥ä¼šå‘˜å¥–åŠ±:", immediateReward.totalRewards)
            end
        end

        local resultData = {
            success = true,
            message = newDays == 0 and "ä¼šå‘˜å·²å–æ¶ˆ" or ("ä¼šå‘˜å¤©æ•°å·²è®¾ç½®ä¸º " .. tostring(newDays) .. " å¤©"),
            oldDaysRemaining = oldDaysRemaining,
            newDays = newDays,
            isActive = isActive,
            immediateReward = immediateReward
        }
        print("âœ… [setMembershipDays] è¿”å›æˆåŠŸç»“æœ:", resultData.message)
        return resultData
    else
        print("âŒ [setMembershipDays] æ•°æ®å­˜å‚¨å¤±è´¥ - success:", success, "result:", result)
        return {
            success = false,
            message = "è®¾ç½®ä¼šå‘˜å¤©æ•°å¤±è´¥: " .. tostring(result or "æœªçŸ¥é”™è¯¯")
        }
    end
end

-- è®¾ç½®ä¼šå‘˜æ¯æ—¥å¥–åŠ±
function AdminDataService.setMembershipReward(userId, dailyReward)
    userId = tostring(userId)
    dailyReward = tonumber(dailyReward) or 100

    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        -- ç¡®ä¿membershipå­—æ®µå­˜åœ¨
        if not currentData.membership then
            currentData.membership = {
                isActive = false,
                membershipId = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 100
            }
        end

        local oldReward = currentData.membership.dailyReward or 100
        currentData.membership.dailyReward = dailyReward
        currentData.updatedAt = os.time()

        return currentData, oldReward, dailyReward
    end)

    if success and result then
        local oldReward, newReward = result[2], result[3]

        return {
            success = true,
            message = "æ¯æ—¥å¥–åŠ±è®¾ç½®æˆåŠŸ",
            oldReward = oldReward,
            newReward = newReward
        }
    else
        return {
            success = false,
            message = "è®¾ç½®æ¯æ—¥å¥–åŠ±å¤±è´¥"
        }
    end
end

-- æ›´æ–°ä¼šå‘˜ä¿¡æ¯
function AdminDataService.updateMembershipInfo(userId, updateData)
    userId = tostring(userId)

    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData or not currentData.membership then
            error("ç”¨æˆ·æ²¡æœ‰æ¿€æ´»çš„ä¼šå‘˜è®°å½•")
        end

        -- æ›´æ–°ç»“æŸæ—¥æœŸ
        if updateData.endDate or updateData.end_date then
            local endDate = updateData.endDate or updateData.end_date
            if type(endDate) == "string" then
                -- å‡è®¾æ—¥æœŸæ ¼å¼ä¸º YYYY-MM-DDï¼Œéœ€è¦è½¬æ¢ä¸ºæ—¶é—´æˆ³
                local year, month, day = endDate:match("(%d+)-(%d+)-(%d+)")
                if year and month and day then
                    endDate = os.time({year = tonumber(year), month = tonumber(month), day = tonumber(day)})
                end
            end
            currentData.membership.endDate = endDate
        end

        -- æ›´æ–°çŠ¶æ€
        local finalStatus = updateData.status ~= nil and updateData.status or updateData.is_active
        if finalStatus ~= nil then
            currentData.membership.isActive = finalStatus == "active" or finalStatus == true
        end

        -- æ›´æ–°æ¯æ—¥å¥–åŠ±
        if updateData.daily_reward_coins ~= nil then
            currentData.membership.dailyReward = updateData.daily_reward_coins
        end

        currentData.updatedAt = os.time()

        return currentData
    end)

    if success then
        return {
            success = true,
            affectedRows = 1,
            membershipId = result.membership.membershipId
        }
    else
        return {
            success = false,
            message = "æ›´æ–°ä¼šå‘˜ä¿¡æ¯å¤±è´¥"
        }
    end
end

-- è·å–ä¼šå‘˜ç»Ÿè®¡
function AdminDataService.getMembershipStats()
    local allUsersData = AdminDataService.getAllUsersData()
    local currentTime = os.time()

    local stats = {
        total_members = 0,
        active_members = 0,
        expired_members = 0
    }

    for userId, userData in pairs(allUsersData) do
        if userData.membership and userData.membership.membershipId then
            stats.total_members = stats.total_members + 1

            if userData.membership.isActive and userData.membership.endDate > currentTime then
                stats.active_members = stats.active_members + 1
            else
                stats.expired_members = stats.expired_members + 1
            end
        end
    end

    return stats
end

-- ==============================================
-- ç®¡ç†å‘˜æ“ä½œæ—¥å¿—
-- ==============================================

-- è®°å½•ç®¡ç†å‘˜æ“ä½œæ—¥å¿—
function AdminDataService.logAdminAction(adminUserId, action, details)
    local logEntry = {
        id = HttpService:GenerateGUID(false),
        admin_user_id = adminUserId,
        action = action,
        details = details,
        timestamp = os.time()
    }

    local success = DataStoreManager.safeUpdateAsync("ADMIN_DATA", "action_logs", function(currentData)
        local logs = currentData or {}
        table.insert(logs, 1, logEntry) -- æœ€æ–°çš„æ—¥å¿—åœ¨å‰é¢

        -- åªä¿ç•™æœ€è¿‘1000æ¡æ—¥å¿—
        if #logs > 1000 then
            for i = 1001, #logs do
                logs[i] = nil
            end
        end

        return logs
    end)

    return success
end

-- ==============================================
-- å·¥å…·å‡½æ•°
-- ==============================================

-- è·å–æ‰€æœ‰ç”¨æˆ·æ•°æ®ï¼ˆå†…éƒ¨å‡½æ•°ï¼Œç”¨äºç»Ÿè®¡å’ŒæŸ¥è¯¢ï¼‰
function AdminDataService.getAllUsersData()
    -- å°è¯•ä»å…¨å±€ç”¨æˆ·ç´¢å¼•è·å–ç”¨æˆ·åˆ—è¡¨
    local allUsersIndex = DataStoreManager.safeGetAsync("USERS", "all_users_index", {})
    local usersData = {}

    -- å¦‚æœæœ‰ç”¨æˆ·ç´¢å¼•ï¼Œé€ä¸ªè·å–ç”¨æˆ·æ•°æ®
    for userId, _ in pairs(allUsersIndex) do
        local userData = DataStoreManager.safeGetAsync("USERS", userId, nil)
        if userData then
            usersData[userId] = userData
        end
    end

    -- å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•ç”¨æˆ·ï¼Œå°è¯•ä»æ¨¡æ‹Ÿæ•°æ®å­˜å‚¨è·å–ï¼ˆStudioæ¨¡å¼ï¼‰
    if next(usersData) == nil and DataStoreManager.isStudioMode then
        local mockUsers = DataStoreManager.getDataStore("USERS")
        return mockUsers or {}
    end

    return usersData
end

print("ğŸ‘‘ ç®¡ç†å‘˜æ•°æ®æœåŠ¡å·²åŠ è½½")

return AdminDataService
