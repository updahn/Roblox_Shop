-- æ™®é€šç”¨æˆ·æ•°æ®æœåŠ¡ - æ›¿æ¢ userSQLOperations.js
-- å¤„ç†æ‰€æœ‰æ™®é€šç”¨æˆ·ç›¸å…³çš„æ•°æ®æ“ä½œ

local DataStoreManager = require(script.Parent.DataStoreManager)
local HttpService = game:GetService("HttpService")

local UserDataService = {}

-- ==============================================
-- ç”¨æˆ·æ•°æ®ç®¡ç†
-- ==============================================

-- åˆ›å»ºæˆ–ç™»å½•ç”¨æˆ·
function UserDataService.createOrLoginUser(userId, username, displayName)
    userId = tostring(userId)
    displayName = displayName or username

    local userData = DataStoreManager.safeGetAsync("USERS", userId, nil)

    if userData then
        -- ç”¨æˆ·å­˜åœ¨ï¼Œæ›´æ–°æœ€åç™»å½•æ—¶é—´
        userData.lastLogin = os.time()
        local success = DataStoreManager.safeSetAsync("USERS", userId, userData)

        if success then
            return {
                isNewUser = false,
                user = {
                    id = userData.userId,
                    username = userData.username,
                    displayName = userData.displayName,
                    coins = userData.coins,
                    isAdmin = userData.isAdmin,
                    lastLogin = userData.lastLogin
                }
            }
        end
    else
        -- åˆ›å»ºæ–°ç”¨æˆ·
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Config = require(ReplicatedStorage:WaitForChild("SharedModules"):WaitForChild("Config"))
        local defaultCoins = Config.GAME.ECONOMY.STARTING_COINS

        local newUserData = DataStoreManager.getDefaultUserData()
        newUserData.userId = userId
        newUserData.username = username
        newUserData.displayName = displayName
        newUserData.coins = defaultCoins

        local success = DataStoreManager.safeSetAsync("USERS", userId, newUserData)

        if success then
            -- æ›´æ–°ç”¨æˆ·ç´¢å¼•
            DataStoreManager.safeUpdateAsync("USERS", "all_users_index", function(currentData)
                local userIndex = currentData or {}
                userIndex[userId] = true
                return userIndex
            end)

            return {
                isNewUser = true,
                user = {
                    id = newUserData.userId,
                    username = newUserData.username,
                    displayName = newUserData.displayName,
                    coins = newUserData.coins,
                    isAdmin = newUserData.isAdmin,
                    lastLogin = newUserData.lastLogin
                }
            }
        end
    end

    return nil
end

-- è·å–ç”¨æˆ·è¯¦ç»†ä¿¡æ¯
function UserDataService.getUserDetails(userId)
    userId = tostring(userId)

    if not userId or userId == "" then
        error("ç”¨æˆ·IDä¸èƒ½ä¸ºç©º")
    end

    local userData = DataStoreManager.safeGetAsync("USERS", userId, nil)

    if userData then
        return {
            id = userData.userId,
            username = userData.username,
            displayName = userData.displayName,
            coins = userData.coins,
            isAdmin = userData.isAdmin,
            status = userData.status,
            createdAt = userData.createdAt,
            updatedAt = userData.updatedAt,
            lastLogin = userData.lastLogin,
            -- ç»Ÿè®¡ä¿¡æ¯
            total_purchases = userData.stats.totalPurchases,
            total_sales = userData.stats.totalSales,
            total_spent = userData.stats.totalSpent,
            total_earned = userData.stats.totalEarned
        }
    end

    return nil
end

-- è·å–ç”¨æˆ·åº“å­˜
function UserDataService.getUserInventory(userId)
    userId = tostring(userId)
    local userData = DataStoreManager.safeGetAsync("USERS", userId, nil)

    if not userData then
        return {}
    end

    local inventory = {}
    local allItems = DataStoreManager.getAllItems()

    for itemId, quantity in pairs(userData.inventory) do
        if quantity > 0 then
            local itemData = allItems[itemId]
            if itemData then
                local sellRate = tonumber(DataStoreManager.getSystemConfig("sell_rate", "0.8")) or 0.8
                local actualSellPrice = itemData.sellPrice > 0 and itemData.sellPrice or (itemData.price * sellRate)

                inventory[itemId] = {
                    item_id = itemId,
                    item_name = itemData.name,
                    description = itemData.description,
                    category = itemData.category,
                    quantity = quantity,
                    current_price = itemData.price,
                    actual_sell_price = actualSellPrice
                }
            end
        end
    end

    return inventory
end

-- ==============================================
-- å•†å“å’Œäº¤æ˜“æ“ä½œ
-- ==============================================

-- è·å–å•†å“åˆ—è¡¨
function UserDataService.getItems(activeOnly)
    if activeOnly == nil then activeOnly = true end

    local allItems = DataStoreManager.getAllItems()
    local items = {}

    for itemId, itemData in pairs(allItems) do
        if not activeOnly or itemData.isActive then
            items[itemId] = {
                id = itemData.id,
                name = itemData.name,
                description = itemData.description,
                price = itemData.price,
                category = itemData.category,
                max_quantity = itemData.maxQuantity,
                current_stock = itemData.currentStock,
                daily_purchase_limit = itemData.dailyPurchaseLimit,
                can_sell = itemData.canSell,
                is_active = itemData.isActive,
                image_url = itemData.imageUrl,
                created_at = itemData.createdAt,
                updated_at = itemData.updatedAt
            }
        end
    end

    return items
end

-- è·å–å•ä¸ªå•†å“ä¿¡æ¯
function UserDataService.getItem(itemId)
    local itemData = DataStoreManager.getItem(itemId)

    if itemData then
        return {
            id = itemData.id,
            name = itemData.name,
            description = itemData.description,
            price = itemData.price,
            category = itemData.category,
            max_quantity = itemData.maxQuantity,
            current_stock = itemData.currentStock,
            daily_purchase_limit = itemData.dailyPurchaseLimit,
            can_sell = itemData.canSell,
            is_active = itemData.isActive,
            image_url = itemData.imageUrl,
            created_at = itemData.createdAt,
            updated_at = itemData.updatedAt
        }
    end

    return nil
end

-- è´­ä¹°å•†å“
function UserDataService.buyItem(userId, itemId, quantity)
    if not userId or userId == "" then
        return {
            success = false,
            message = "ç”¨æˆ·IDä¸èƒ½ä¸ºç©º"
        }
    end
    userId = tostring(userId)

    -- æ£€æŸ¥æ˜¯å¦ä¸ºä¼šå‘˜å•†å“ï¼Œå¦‚æœæ˜¯åˆ™è°ƒç”¨ä¸“é—¨çš„ä¼šå‘˜è´­ä¹°å‡½æ•°
    local membershipItems = {"monthly_membership", "weekly_membership", "quarterly_membership", "premium_membership", "vip_membership"}
    for _, membershipItemId in ipairs(membershipItems) do
        if itemId == membershipItemId then
            print("ğŸ¯ [buyItem] æ£€æµ‹åˆ°ä¼šå‘˜å•†å“ï¼Œè°ƒç”¨ä¸“é—¨çš„ä¼šå‘˜è´­ä¹°é€»è¾‘:", itemId)
            local success, result = pcall(function()
                return UserDataService.buyMembershipItem(userId, itemId, quantity)
            end)

            if success and result then
                print("âœ… [buyItem] ä¼šå‘˜å•†å“è´­ä¹°æˆåŠŸ:", itemId, "ç”¨æˆ·:", userId)
                return {
                    success = true,
                    message = "ä¼šå‘˜è´­ä¹°æˆåŠŸ"
                }
            else
                print("âŒ [buyItem] ä¼šå‘˜å•†å“è´­ä¹°å¤±è´¥:", itemId, "é”™è¯¯:", result)
                return {
                    success = false,
                    message = tostring(result) or "ä¼šå‘˜è´­ä¹°å¤±è´¥"
                }
            end
        end
    end

    -- è·å–å•†å“ä¿¡æ¯
    local itemData = DataStoreManager.getItem(itemId)
    if not itemData or not itemData.isActive then
        return {
            success = false,
            message = "å•†å“ä¸å­˜åœ¨æˆ–å·²ç¦ç”¨"
        }
    end

    -- æ£€æŸ¥åº“å­˜
    if itemData.currentStock ~= -1 and itemData.currentStock < quantity then
        return {
            success = false,
            message = string.format("åº“å­˜ä¸è¶³ï¼Œå½“å‰åº“å­˜: %dï¼Œå°è¯•è´­ä¹°: %d", itemData.currentStock, quantity)
        }
    end

    -- æ£€æŸ¥è´­ä¹°æ•°é‡é™åˆ¶
    if itemData.maxQuantity and quantity > itemData.maxQuantity then
        return {
            success = false,
            message = string.format("è´­ä¹°æ•°é‡è¶…è¿‡é™åˆ¶ï¼Œæœ€å¤§å¯è´­ä¹°: %d", itemData.maxQuantity)
        }
    end

    -- æ£€æŸ¥æ¯æ—¥é™è´­ï¼ˆä»äº¤æ˜“è®°å½•ä¸­ç»Ÿè®¡ï¼‰
    if itemData.dailyPurchaseLimit then
        local todayPurchased = UserDataService.getTodayPurchaseCount(userId, itemId)
        if todayPurchased + quantity > itemData.dailyPurchaseLimit then
            local remaining = itemData.dailyPurchaseLimit - todayPurchased
            return {
                success = false,
                message = string.format("æ¯æ—¥è´­ä¹°é™é¢å·²è¾¾åˆ°ï¼Œä»Šæ—¥å‰©ä½™å¯è´­ä¹°: %dï¼Œå°è¯•è´­ä¹°: %d", remaining, quantity)
            }
        end
    end

    -- è®¡ç®—æ€»ä»·
    local totalCost = itemData.price * quantity

    -- å…ˆè·å–ç”¨æˆ·æ•°æ®æ£€æŸ¥
    local currentUserData = DataStoreManager.safeGetAsync("USERS", userId, nil)
    if not currentUserData then
        return {
            success = false,
            message = "ç”¨æˆ·ä¸å­˜åœ¨"
        }
    end

    -- æ£€æŸ¥é‡‘å¸
    if currentUserData.coins < totalCost then
        return {
            success = false,
            message = string.format("é‡‘å¸ä¸è¶³ï¼Œéœ€è¦: %dï¼Œå½“å‰: %d", totalCost, currentUserData.coins)
        }
    end

    -- åŸå­æ›´æ–°ç”¨æˆ·æ•°æ®
    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            return nil  -- è¿”å› nil è¡¨ç¤ºå–æ¶ˆæ›´æ–°
        end

        -- å†æ¬¡æ£€æŸ¥é‡‘å¸ï¼ˆå¯èƒ½åœ¨æ­¤æœŸé—´æœ‰å˜åŒ–ï¼‰
        if currentData.coins < totalCost then
            return nil  -- è¿”å› nil è¡¨ç¤ºå–æ¶ˆæ›´æ–°
        end

        -- æ‰£é™¤é‡‘å¸
        local coinsBefore = currentData.coins
        currentData.coins = currentData.coins - totalCost

        -- æ›´æ–°åº“å­˜
        if not currentData.inventory[itemId] then
            currentData.inventory[itemId] = 0
        end
        currentData.inventory[itemId] = currentData.inventory[itemId] + quantity

        -- æ›´æ–°ç»Ÿè®¡
        currentData.stats.totalPurchases = currentData.stats.totalPurchases + 1
        currentData.stats.totalSpent = currentData.stats.totalSpent + totalCost
        currentData.updatedAt = os.time()

        return currentData
    end)

    if not success or not result then
        return {
            success = false,
            message = "è´­ä¹°å¤±è´¥ï¼šæ•°æ®æ›´æ–°å¤±è´¥æˆ–é‡‘å¸ä¸è¶³"
        }
    end

    -- æ›´æ–°å•†å“åº“å­˜ï¼ˆå¦‚æœä¸æ˜¯æ— é™åº“å­˜ï¼‰
    if itemData.currentStock ~= -1 then
        local success = DataStoreManager.safeUpdateAsync("ITEMS", "all_items", function(currentData)
            local items = currentData or {}
            if items[itemId] then
                items[itemId].currentStock = items[itemId].currentStock - quantity
                items[itemId].updatedAt = os.time()
            end
            return items
        end)

        if not success then
            -- å¦‚æœå•†å“åº“å­˜æ›´æ–°å¤±è´¥ï¼Œéœ€è¦å›æ»šç”¨æˆ·æ•°æ®
            warn("âš ï¸ å•†å“åº“å­˜æ›´æ–°å¤±è´¥ï¼Œä½†ç”¨æˆ·è´­ä¹°å·²å®Œæˆ")
        end
    end

    -- è®°å½•äº¤æ˜“
    UserDataService.addTransactionRecord(userId, "buy", itemId, quantity, itemData.price, totalCost, result.coins + totalCost, result.coins)

    return {
        success = true,
        totalCost = totalCost,
        itemPrice = itemData.price,
        quantity = quantity
    }
end

-- å‡ºå”®å•†å“
function UserDataService.sellItem(userId, itemId, quantity)
    userId = tostring(userId)

    -- è·å–å•†å“ä¿¡æ¯
    local itemData = DataStoreManager.getItem(itemId)
    if not itemData then
        return nil, "å•†å“ä¸å­˜åœ¨"
    end

    -- æ£€æŸ¥æ˜¯å¦å¯ä»¥å‡ºå”®
    if not itemData.canSell then
        return nil, "è¯¥å•†å“æ— æ³•å–å‡º"
    end

    -- è®¡ç®—å‡ºå”®ä»·æ ¼
    local sellRate = tonumber(DataStoreManager.getSystemConfig("sell_rate", "0.8")) or 0.8
    local unitSellPrice = itemData.sellPrice > 0 and itemData.sellPrice or (itemData.price * sellRate)
    local totalValue = unitSellPrice * quantity

    -- åŸå­æ›´æ–°ç”¨æˆ·æ•°æ®
    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            return nil, "ç”¨æˆ·ä¸å­˜åœ¨"
        end

        -- æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‹¥æœ‰è¶³å¤Ÿçš„å•†å“
        local ownedQuantity = currentData.inventory[itemId] or 0
        if ownedQuantity < quantity then
            return nil, string.format("æ‹¥æœ‰çš„ç‰©å“æ•°é‡ä¸è¶³ï¼Œæ‹¥æœ‰: %dï¼Œå°è¯•å‡ºå”®: %d", ownedQuantity, quantity)
        end

        -- å¢åŠ é‡‘å¸
        local coinsBefore = currentData.coins
        currentData.coins = currentData.coins + totalValue

        -- å‡å°‘åº“å­˜
        currentData.inventory[itemId] = currentData.inventory[itemId] - quantity

        -- æ›´æ–°ç»Ÿè®¡
        currentData.stats.totalSales = currentData.stats.totalSales + 1
        currentData.stats.totalEarned = currentData.stats.totalEarned + totalValue
        currentData.updatedAt = os.time()

        return currentData
    end)

    if not success then
        return nil, "å‡ºå”®å¤±è´¥ï¼šæ•°æ®æ›´æ–°å¤±è´¥"
    end

    -- è®°å½•äº¤æ˜“
    UserDataService.addTransactionRecord(userId, "sell", itemId, quantity, unitSellPrice, totalValue, result.coins - totalValue, result.coins)

    return {
        success = true,
        totalValue = totalValue,
        unitSellPrice = unitSellPrice,
        quantity = quantity
    }
end

-- ==============================================
-- äº¤æ˜“è®°å½•ç®¡ç†
-- ==============================================

-- æ·»åŠ äº¤æ˜“è®°å½•
function UserDataService.addTransactionRecord(userId, transactionType, itemId, quantity, unitPrice, totalAmount, coinsBefore, coinsAfter, notes)
    local transactionRecord = DataStoreManager.createTransactionRecord(
        userId, transactionType, itemId, quantity, unitPrice, totalAmount, coinsBefore, coinsAfter, notes
    )

    -- å°†äº¤æ˜“è®°å½•æ·»åŠ åˆ°ç”¨æˆ·çš„äº¤æ˜“å†å²ä¸­
    local userTransactionsKey = "user_transactions_" .. userId
    local success, newData = DataStoreManager.safeUpdateAsync("TRANSACTIONS", userTransactionsKey, function(currentData)
        local transactions = currentData or {}
        table.insert(transactions, 1, transactionRecord) -- æœ€æ–°çš„äº¤æ˜“åœ¨å‰é¢

        -- é™åˆ¶äº¤æ˜“è®°å½•æ•°é‡ï¼ˆä¿ç•™æœ€è¿‘50æ¡ï¼‰
        local maxRecords = 50
        if #transactions > maxRecords then
            for i = maxRecords + 1, #transactions do
                transactions[i] = nil
            end
        end

        return transactions
    end)

    return success
end

-- è·å–ç”¨æˆ·äº¤æ˜“è®°å½•
function UserDataService.getUserTransactions(userId, limit)
    userId = tostring(userId)
    limit = limit or 50

    local userTransactionsKey = "user_transactions_" .. userId
    local transactions = DataStoreManager.safeGetAsync("TRANSACTIONS", userTransactionsKey, {})

    -- é™åˆ¶è¿”å›æ•°é‡
    if limit and limit > 0 and #transactions > limit then
        local limitedTransactions = {}
        for i = 1, math.min(limit, #transactions) do
            limitedTransactions[i] = transactions[i]
        end
        transactions = limitedTransactions
    end

    -- è½¬æ¢æ ¼å¼ä»¥åŒ¹é…åŸæœ‰API
    local formattedTransactions = {}
    local allItems = DataStoreManager.getAllItems()

    for _, transaction in ipairs(transactions) do
        local itemData = allItems[transaction.itemId or ""]

        -- ç¡®ä¿æ—¶é—´æˆ³å­—æ®µå­˜åœ¨å’Œæ­£ç¡®
        local createdAt = transaction.createdAt or transaction.timestamp or os.time()
        local transactionDate = transaction.transactionDate or os.date("%Y-%m-%d", createdAt)

        table.insert(formattedTransactions, {
            id = transaction.id,
            item_id = transaction.itemId,
            item_name = itemData and itemData.name or "æœªçŸ¥å•†å“",
            type = transaction.type,
            quantity = transaction.quantity,
            unit_price = transaction.unitPrice,
            total_amount = transaction.totalAmount,
            transaction_date = transactionDate,
            created_at = createdAt,
            timestamp = createdAt -- æ·»åŠ timestampå­—æ®µä»¥ä¿è¯å…¼å®¹æ€§
        })
    end

    return formattedTransactions
end

-- è·å–ä»Šæ—¥è´­ä¹°æ•°é‡ï¼ˆç”¨äºæ¯æ—¥é™è´­æ£€æŸ¥ï¼‰
function UserDataService.getTodayPurchaseCount(userId, itemId)
    userId = tostring(userId)
    local today = os.date("%Y-%m-%d")

    local userTransactionsKey = "user_transactions_" .. userId
    local transactions = DataStoreManager.safeGetAsync("TRANSACTIONS", userTransactionsKey, {})

    local todayCount = 0
    for _, transaction in ipairs(transactions) do
        if transaction.itemId == itemId and transaction.type == "buy" and transaction.transactionDate == today then
            todayCount = todayCount + transaction.quantity
        end
    end

    return todayCount
end

-- è·å–ç”¨æˆ·äº¤æ˜“ç»Ÿè®¡
function UserDataService.getUserTransactionStats(userId)
    userId = tostring(userId)

    local userTransactionsKey = "user_transactions_" .. userId
    local transactions = DataStoreManager.safeGetAsync("TRANSACTIONS", userTransactionsKey, {})

    local stats = {
        buy = {count = 0, total_amount = 0},
        sell = {count = 0, total_amount = 0}
    }

    for _, transaction in ipairs(transactions) do
        if transaction.type == "buy" or transaction.type == "sell" then
            stats[transaction.type].count = stats[transaction.type].count + 1
            stats[transaction.type].total_amount = stats[transaction.type].total_amount + transaction.totalAmount
        end
    end

    return {
        {type = "buy", count = stats.buy.count, total_amount = stats.buy.total_amount},
        {type = "sell", count = stats.sell.count, total_amount = stats.sell.total_amount}
    }
end

-- ==============================================
-- ä¼šå‘˜ç³»ç»Ÿ
-- ==============================================

-- ä¼šå‘˜çŠ¶æ€ç¼“å­˜ï¼ˆé¿å…é¢‘ç¹æŸ¥è¯¢æ•°æ®åº“ï¼‰
local membershipCache = {}
local cacheExpiry = {} -- ç¼“å­˜è¿‡æœŸæ—¶é—´
local CACHE_DURATION = 300 -- ç¼“å­˜5åˆ†é’Ÿ

-- æ¸…ç†è¿‡æœŸç¼“å­˜
local function cleanupExpiredCache()
    local currentTime = os.time()
    for userId, expiry in pairs(cacheExpiry) do
        if currentTime > expiry then
            membershipCache[userId] = nil
            cacheExpiry[userId] = nil
        end
    end
end

-- è·å–ç¼“å­˜çš„ä¼šå‘˜çŠ¶æ€
local function getCachedMembershipStatus(userId)
    cleanupExpiredCache()

    local cached = membershipCache[userId]
    local expiry = cacheExpiry[userId]

    if cached and expiry and os.time() < expiry then
        return cached
    end

    return nil
end

-- ç¼“å­˜ä¼šå‘˜çŠ¶æ€
local function cacheMembershipStatus(userId, status)
    membershipCache[userId] = status
    cacheExpiry[userId] = os.time() + CACHE_DURATION
end

-- æ¸…é™¤ç‰¹å®šç”¨æˆ·çš„ç¼“å­˜
local function clearMembershipCache(userId)
    membershipCache[userId] = nil
    cacheExpiry[userId] = nil
end

-- å¯¼å‡ºæ¸…é™¤ç¼“å­˜å‡½æ•°ä¾›å¤–éƒ¨ä½¿ç”¨
function UserDataService.clearMembershipCache(userId)
    clearMembershipCache(userId)
    print("ğŸ§¹ [UserDataService] å·²æ¸…é™¤ç”¨æˆ·ä¼šå‘˜ç¼“å­˜:", userId)
end

-- æ¸…é™¤æ‰€æœ‰ç¼“å­˜ï¼ˆç®¡ç†å‘˜åŠŸèƒ½ï¼‰
function UserDataService.clearAllMembershipCache()
    membershipCache = {}
    cacheExpiry = {}
    print("âœ… [ä¼šå‘˜ç³»ç»Ÿ] å·²æ¸…é™¤æ‰€æœ‰ä¼šå‘˜çŠ¶æ€ç¼“å­˜")
end

-- è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯ï¼ˆè°ƒè¯•ç”¨ï¼‰
function UserDataService.getMembershipCacheStats()
    cleanupExpiredCache()
    local cacheCount = 0
    for _ in pairs(membershipCache) do
        cacheCount = cacheCount + 1
    end

    return {
        cachedUsers = cacheCount,
        cacheDuration = CACHE_DURATION
    }
end

-- éªŒè¯å’Œä¿®å¤ä¼šå‘˜æ•°æ®å®Œæ•´æ€§
function UserDataService.validateAndRepairMembershipData(userId)
    userId = tostring(userId)

    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            return nil
        end

        local repaired = false

        -- ç¡®ä¿ä¼šå‘˜æ•°æ®ç»“æ„å­˜åœ¨
        if not currentData.membership then
            currentData.membership = {
                isActive = false,
                membershipId = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 100
            }
            repaired = true
        end

        -- éªŒè¯ä¼šå‘˜æ•°æ®å­—æ®µ
        local membership = currentData.membership
        if type(membership.isActive) ~= "boolean" then
            membership.isActive = false
            repaired = true
        end

        if membership.dailyReward and type(membership.dailyReward) ~= "number" then
            membership.dailyReward = 100
            repaired = true
        end

        -- æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§ï¼šå¦‚æœæœ‰ä¼šå‘˜IDä½†æ²¡æœ‰ç»“æŸæ—¥æœŸï¼Œæˆ–è€…ç›¸å
        if membership.membershipId and not membership.endDate then
            warn("âš ï¸ [æ•°æ®ä¿®å¤] ç”¨æˆ·", userId, "æœ‰ä¼šå‘˜IDä½†æ²¡æœ‰ç»“æŸæ—¥æœŸï¼Œåœç”¨ä¼šå‘˜")
            membership.isActive = false
            membership.membershipId = nil
            repaired = true
        elseif not membership.membershipId and membership.endDate then
            warn("âš ï¸ [æ•°æ®ä¿®å¤] ç”¨æˆ·", userId, "æœ‰ç»“æŸæ—¥æœŸä½†æ²¡æœ‰ä¼šå‘˜IDï¼Œæ¸…é™¤æ—¥æœŸ")
            membership.endDate = nil
            membership.startDate = nil
            membership.isActive = false
            repaired = true
        end

        -- æ£€æŸ¥è¿‡æœŸä¼šå‘˜
        if membership.isActive and membership.endDate then
            local currentTime = os.time()
            if currentTime >= membership.endDate then
                membership.isActive = false
                repaired = true
            end
        end

        if repaired then
            currentData.updatedAt = os.time()
            print("ğŸ”§ [æ•°æ®ä¿®å¤] ç”¨æˆ·", userId, "çš„ä¼šå‘˜æ•°æ®å·²ä¿®å¤")
        end

        return currentData
    end)

    if success then
        -- æ¸…é™¤ç¼“å­˜ä»¥ç¡®ä¿è·å–æœ€æ–°æ•°æ®
        clearMembershipCache(userId)
    end

    return success, result
end

-- æ‰¹é‡ä¿®å¤æ‰€æœ‰ç”¨æˆ·çš„ä¼šå‘˜æ•°æ®ï¼ˆç®¡ç†å‘˜åŠŸèƒ½ï¼‰
function UserDataService.batchRepairMembershipData()
    local allUsers = DataStoreManager.safeGetAsync("USERS", "all_users", {})
    if not allUsers then
        return {success = false, message = "æ— æ³•è·å–ç”¨æˆ·åˆ—è¡¨"}
    end

    local repairCount = 0
    local errorCount = 0

    for userId, _ in pairs(allUsers) do
        local success, _ = UserDataService.validateAndRepairMembershipData(userId)
        if success then
            repairCount = repairCount + 1
        else
            errorCount = errorCount + 1
        end
    end

    print(string.format("ğŸ”§ [æ‰¹é‡ä¿®å¤] å®Œæˆä¼šå‘˜æ•°æ®ä¿®å¤ï¼ŒæˆåŠŸ: %dï¼Œå¤±è´¥: %d", repairCount, errorCount))

    return {
        success = true,
        repaired = repairCount,
        errors = errorCount,
        total = repairCount + errorCount
    }
end

-- è¯Šæ–­ä¼šå‘˜ç³»ç»Ÿå¥åº·çŠ¶æ€ï¼ˆç®¡ç†å‘˜åŠŸèƒ½ï¼‰
function UserDataService.diagnoseMembershipSystem()
    local stats = {
        totalUsers = 0,
        activeMembers = 0,
        expiredMembers = 0,
        corruptedData = 0,
        cacheStats = UserDataService.getMembershipCacheStats()
    }

    local allUsers = DataStoreManager.safeGetAsync("USERS", "all_users", {})
    if not allUsers then
        return {success = false, message = "æ— æ³•è·å–ç”¨æˆ·åˆ—è¡¨", stats = stats}
    end

    for userId, _ in pairs(allUsers) do
        stats.totalUsers = stats.totalUsers + 1

        local membershipStatus = UserDataService.getMembershipStatus(userId)
        if membershipStatus.error then
            stats.corruptedData = stats.corruptedData + 1
        elseif membershipStatus.isValid then
            stats.activeMembers = stats.activeMembers + 1
        elseif membershipStatus.hasMembership then
            stats.expiredMembers = stats.expiredMembers + 1
        end
    end

    print("ğŸ“Š [ä¼šå‘˜ç³»ç»Ÿè¯Šæ–­]")
    print("  æ€»ç”¨æˆ·æ•°:", stats.totalUsers)
    print("  æ´»è·ƒä¼šå‘˜:", stats.activeMembers)
    print("  è¿‡æœŸä¼šå‘˜:", stats.expiredMembers)
    print("  æ•°æ®æŸå:", stats.corruptedData)
    print("  ç¼“å­˜ç”¨æˆ·:", stats.cacheStats.cachedUsers)

    return {success = true, stats = stats}
end

-- è·å–ä¼šå‘˜çŠ¶æ€
function UserDataService.getMembershipStatus(userId)
    -- å‚æ•°éªŒè¯
    if not userId or userId == "" then
        warn("âŒ [ä¼šå‘˜çŠ¶æ€] æ— æ•ˆçš„ç”¨æˆ·ID")
        return {
            hasMembership = false,
            isValid = false,
            daysRemaining = 0,
            membershipType = nil,
            startDate = nil,
            endDate = nil,
            dailyReward = 0,
            error = "æ— æ•ˆçš„ç”¨æˆ·ID"
        }
    end

    userId = tostring(userId)

    -- å°è¯•ä»ç¼“å­˜è·å–
    local cached = getCachedMembershipStatus(userId)
    if cached then
        -- å¯¹äºæ— æ•ˆä¼šå‘˜æˆ–è€…æ²¡æœ‰ç»“æŸæ—¥æœŸçš„ç›´æ¥è¿”å›ç¼“å­˜
        if not cached.isValid or not cached.endDate then
            return cached
        end

        -- éªŒè¯ç¼“å­˜çš„ä¼šå‘˜æ˜¯å¦çœŸçš„è¿‡æœŸï¼ˆç®€å•æ£€æŸ¥å‰©ä½™å¤©æ•°ï¼‰
        if cached.daysRemaining and cached.daysRemaining <= 0 then
            -- ç¼“å­˜æ˜¾ç¤ºå·²è¿‡æœŸï¼Œæ¸…é™¤ç¼“å­˜é‡æ–°æŸ¥è¯¢
            clearMembershipCache(userId)
        else
            return cached
        end
    end

    -- ä½¿ç”¨ pcall åŒ…è£…æ•°æ®è·å–ä»¥æ•è·å¼‚å¸¸
    local success, userData = pcall(function()
        return DataStoreManager.safeGetAsync("USERS", userId, nil)
    end)

    if not success then
        warn("âŒ [ä¼šå‘˜çŠ¶æ€] è·å–ç”¨æˆ·æ•°æ®å¤±è´¥:", userData)
        return {
            hasMembership = false,
            isValid = false,
            daysRemaining = 0,
            membershipType = nil,
            startDate = nil,
            endDate = nil,
            dailyReward = 0,
            error = "æ•°æ®è·å–å¤±è´¥"
        }
    end

    -- æ£€æŸ¥ç”¨æˆ·æ•°æ®æ˜¯å¦å­˜åœ¨
    if not userData then
        warn("âš ï¸ [ä¼šå‘˜çŠ¶æ€] ç”¨æˆ·ä¸å­˜åœ¨:", userId)
        return {
            hasMembership = false,
            isValid = false,
            daysRemaining = 0,
            membershipType = nil,
            startDate = nil,
            endDate = nil,
            dailyReward = 0,
            error = "ç”¨æˆ·ä¸å­˜åœ¨"
        }
    end

    -- æ£€æŸ¥ä¼šå‘˜æ•°æ®ç»“æ„
    if not userData.membership then
        -- ä¸ºç”¨æˆ·åˆå§‹åŒ–ä¼šå‘˜æ•°æ®ç»“æ„
        local initSuccess = pcall(function()
            DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
                if currentData then
                    currentData.membership = {
                        isActive = false,
                        membershipId = nil,
                        startDate = nil,
                        endDate = nil,
                        dailyReward = 100
                    }
                    currentData.updatedAt = os.time()
                end
                return currentData
            end)
        end)

        if not initSuccess then
            warn("âš ï¸ [ä¼šå‘˜çŠ¶æ€] åˆå§‹åŒ–ä¼šå‘˜æ•°æ®å¤±è´¥:", userId)
        end

        return {
            hasMembership = false,
            isValid = false,
            daysRemaining = 0,
            membershipType = nil,
            startDate = nil,
            endDate = nil,
            dailyReward = 100
        }
    end

    local membership = userData.membership

    -- ç¡®ä¿ä¼šå‘˜æ•°æ®ç»“æ„å®Œæ•´æ€§
    if type(membership) ~= "table" then
        warn("âŒ [ä¼šå‘˜çŠ¶æ€] ä¼šå‘˜æ•°æ®ç»“æ„æŸå:", userId)
        return {
            hasMembership = false,
            isValid = false,
            daysRemaining = 0,
            membershipType = nil,
            startDate = nil,
            endDate = nil,
            dailyReward = 100,
            error = "ä¼šå‘˜æ•°æ®ç»“æ„æŸå"
        }
    end

    -- æ£€æŸ¥ä¼šå‘˜æ˜¯å¦æœ‰æ•ˆ
    local isValid = false
    local daysRemaining = 0
    local currentTime = os.time()

    if membership.isActive and membership.endDate and type(membership.endDate) == "number" then
        local endTime = membership.endDate

        if currentTime < endTime then
            isValid = true
            daysRemaining = math.max(0, math.ceil((endTime - currentTime) / (24 * 60 * 60)))
        else
            -- ä¼šå‘˜å·²è¿‡æœŸï¼Œå¼‚æ­¥æ›´æ–°çŠ¶æ€é¿å…é˜»å¡
            task.spawn(function()
                local deactivateSuccess = pcall(function()
                    UserDataService.deactivateMembership(userId)
                end)
                if not deactivateSuccess then
                    warn("âš ï¸ [ä¼šå‘˜çŠ¶æ€] åœç”¨è¿‡æœŸä¼šå‘˜å¤±è´¥:", userId)
                end
            end)
        end
    elseif membership.isActive and not membership.endDate then
        -- æ•°æ®ä¸ä¸€è‡´ï¼Œä¼šå‘˜æ¿€æ´»ä½†æ²¡æœ‰ç»“æŸæ—¥æœŸ
        warn("âš ï¸ [ä¼šå‘˜çŠ¶æ€] æ•°æ®ä¸ä¸€è‡´ - ä¼šå‘˜æ¿€æ´»ä½†æ²¡æœ‰ç»“æŸæ—¥æœŸ:", userId)
        isValid = false
    end

    -- å®‰å…¨åœ°æ ¼å¼åŒ–æ—¥æœŸ
    local function formatDate(timestamp)
        if not timestamp or type(timestamp) ~= "number" then
            return nil
        end
        local success, formattedDate = pcall(function()
            return os.date("%Y-%m-%d", timestamp)
        end)
        return success and formattedDate or nil
    end

    local result = {
        hasMembership = membership.membershipId ~= nil and membership.membershipId ~= "",
        isValid = isValid,
        membershipId = membership.membershipId,
        membershipType = "monthly",
        startDate = formatDate(membership.startDate),
        endDate = formatDate(membership.endDate),
        dailyReward = tonumber(membership.dailyReward) or 100,
        daysRemaining = daysRemaining,
        isActive = membership.isActive == true,
        createdAt = membership.createdAt
    }

    -- æ·»åŠ è°ƒè¯•ä¿¡æ¯ï¼ˆä»…åœ¨å¼€å‘ç¯å¢ƒï¼‰
    if game:GetService("RunService"):IsStudio() then
        print("ğŸ” [ä¼šå‘˜çŠ¶æ€] ç”¨æˆ·:", userId, "æœ‰æ•ˆ:", isValid, "å‰©ä½™å¤©æ•°:", daysRemaining)
    end

    -- ç¼“å­˜ç»“æœ
    cacheMembershipStatus(userId, result)

    return result
end

-- åœç”¨è¿‡æœŸä¼šå‘˜
function UserDataService.deactivateMembership(userId)
    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if currentData and currentData.membership then
            currentData.membership.isActive = false
            currentData.updatedAt = os.time()
        end
        return currentData
    end)

    -- æ¸…é™¤ç¼“å­˜
    if success then
        clearMembershipCache(userId)
    end

    return success
end

-- è´­ä¹°ä¼šå‘˜å•†å“
function UserDataService.buyMembershipItem(userId, itemId, quantity)
    userId = tostring(userId)

    -- æ”¯æŒçš„ä¼šå‘˜å•†å“ç±»å‹
    local validMembershipItems = {
        monthly_membership = {days = 30, reward = 100},
        weekly_membership = {days = 7, reward = 100},
        quarterly_membership = {days = 90, reward = 100},
        premium_membership = {days = 30, reward = 200},
        vip_membership = {days = 365, reward = 150}
    }

    if not validMembershipItems[itemId] then
        error("æ— æ•ˆçš„ä¼šå‘˜å•†å“ID")
    end

    -- è·å–ä¼šå‘˜å•†å“ä»·æ ¼
    local itemData = DataStoreManager.getItem(itemId)
    if not itemData or not itemData.isActive then
        error("ä¼šå‘˜å•†å“ä¸å­˜åœ¨æˆ–å·²ä¸‹æ¶")
    end

    local membershipConfig = validMembershipItems[itemId]
    local durationDays = membershipConfig.days * quantity
    local dailyReward = membershipConfig.reward
    local totalCost = itemData.price * quantity

    -- åŸå­æ›´æ–°ç”¨æˆ·æ•°æ®
    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        -- ç¡®ä¿ membership å­—æ®µå­˜åœ¨
        if not currentData.membership then
            currentData.membership = {
                isActive = false,
                membershipId = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 100
            }
        end

        -- æ£€æŸ¥é‡‘å¸
        if currentData.coins < totalCost then
            error(string.format("é‡‘å¸ä¸è¶³ï¼Œéœ€è¦: %dï¼Œå½“å‰: %d", totalCost, currentData.coins))
        end

        -- æ‰£é™¤é‡‘å¸
        local coinsBefore = currentData.coins
        currentData.coins = currentData.coins - totalCost

        -- è®¾ç½®ä¼šå‘˜ä¿¡æ¯
        local now = os.time()
        local startDate = now
        local endDate = now + (durationDays * 24 * 60 * 60)

        -- å¦‚æœå·²æœ‰æ´»è·ƒä¼šå‘˜ï¼Œä»ç»“æŸæ—¥æœŸå¼€å§‹å»¶æœŸ
        if currentData.membership.isActive and currentData.membership.endDate and currentData.membership.endDate > now then
            startDate = currentData.membership.endDate
            endDate = startDate + (durationDays * 24 * 60 * 60)
        end

        -- ä¿ç•™ç°æœ‰çš„ membershipIdï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”Ÿæˆæ–°çš„
        local membershipId = currentData.membership.membershipId or HttpService:GenerateGUID(false)

        currentData.membership = {
            isActive = true,
            membershipId = membershipId,
            startDate = startDate,
            endDate = endDate,
            dailyReward = dailyReward,
            createdAt = now
        }

        -- ç¡®ä¿ç»Ÿè®¡æ•°æ®å­˜åœ¨
        if not currentData.stats then
            currentData.stats = {
                totalPurchases = 0,
                totalSpent = 0,
                totalSold = 0,
                totalEarned = 0
            }
        end

        -- æ›´æ–°ç»Ÿè®¡
        currentData.stats.totalPurchases = currentData.stats.totalPurchases + 1
        currentData.stats.totalSpent = currentData.stats.totalSpent + totalCost
        currentData.updatedAt = now

        print("âœ… [buyMembershipItem] ä¼šå‘˜æ•°æ®å·²æ›´æ–° - ç”¨æˆ·:", userId, "å•†å“:", itemId, "å¤©æ•°:", durationDays, "ç»“æŸæ—¶é—´:", os.date("%Y-%m-%d %H:%M:%S", endDate))

        return currentData
    end)

    if not success then
        error("è´­ä¹°ä¼šå‘˜å¤±è´¥ï¼šæ•°æ®æ›´æ–°å¤±è´¥")
    end

    -- æ¸…é™¤ç¼“å­˜
    clearMembershipCache(userId)

    -- è®°å½•äº¤æ˜“
    UserDataService.addTransactionRecord(userId, "membership_purchase", itemId, quantity, itemData.price, totalCost, result.coins + totalCost, result.coins, string.format("è´­ä¹°%dä¸ªæœˆä¼šå‘˜ï¼Œæœ‰æ•ˆæœŸ%då¤©", quantity, durationDays))

    -- ç«‹å³å‘é€å½“æ—¥å¥–åŠ±
    local immediateReward = UserDataService.claimTodayMembershipReward(userId)

    return {
        success = true,
        totalCost = totalCost,
        membershipDays = durationDays,
        dailyReward = dailyReward,
        startDate = os.date("%Y-%m-%d", result.membership.startDate),
        endDate = os.date("%Y-%m-%d", result.membership.endDate),
        membershipId = result.membership.membershipId,
        immediateReward = immediateReward
    }
end

-- å¤„ç†ç™»å½•å¥–åŠ±
function UserDataService.processLoginRewards(userId)
    userId = tostring(userId)

    -- è·å–ç”¨æˆ·æ•°æ®å’Œä¼šå‘˜çŠ¶æ€
    local membershipStatus = UserDataService.getMembershipStatus(userId)

    -- æ£€æŸ¥è·å–ä¼šå‘˜çŠ¶æ€æ˜¯å¦å‡ºé”™
    if membershipStatus.error then
        warn("âš ï¸ [ç™»å½•å¥–åŠ±] è·å–ä¼šå‘˜çŠ¶æ€å¤±è´¥:", membershipStatus.error)
        return {
            success = false,
            message = "è·å–ä¼šå‘˜çŠ¶æ€å¤±è´¥: " .. membershipStatus.error,
            canClaim = false,
            totalRewards = 0
        }
    end

    if not membershipStatus.isValid then
        return {
            success = false,
            message = "æ²¡æœ‰æœ‰æ•ˆçš„ä¼šå‘˜èµ„æ ¼",
            canClaim = false,
            totalRewards = 0
        }
    end

    local today = os.date("%Y-%m-%d")
    local dailyReward = membershipStatus.dailyReward

    -- æ£€æŸ¥ä»Šæ—¥æ˜¯å¦å·²é¢†å–
    local rewardsKey = "daily_rewards_" .. userId
    local rewardHistory = DataStoreManager.safeGetAsync("DAILY_REWARDS", rewardsKey, {})

    -- æ£€æŸ¥ä»Šæ—¥æ˜¯å¦å·²é¢†å–
    for _, record in ipairs(rewardHistory) do
        if record.date == today then
            return {
                success = false,
                message = "ä»Šæ—¥å¥–åŠ±å·²é¢†å–",
                canClaim = false,
                alreadyClaimed = true,
                totalRewards = 0
            }
        end
    end

    -- åŸå­æ›´æ–°ç”¨æˆ·é‡‘å¸
    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        local coinsBefore = currentData.coins
        currentData.coins = currentData.coins + dailyReward
        currentData.updatedAt = os.time()

        return currentData
    end)

    if not success then
        return {
            success = false,
            message = "å¥–åŠ±é¢†å–å¤±è´¥",
            canClaim = false,
            totalRewards = 0
        }
    end

    -- è®°å½•æ¯æ—¥å¥–åŠ±
    local success2 = DataStoreManager.safeUpdateAsync("DAILY_REWARDS", rewardsKey, function(currentData)
        local rewards = currentData or {}
        table.insert(rewards, 1, {
            date = today,
            reward_coins = dailyReward,
            membership_id = membershipStatus.membershipId,
            claimed_at = os.time()
        })

        -- åªä¿ç•™æœ€è¿‘30å¤©çš„è®°å½•
        if #rewards > 30 then
            for i = 31, #rewards do
                rewards[i] = nil
            end
        end

        return rewards
    end)

    -- è®°å½•äº¤æ˜“
    UserDataService.addTransactionRecord(userId, "daily_reward", nil, 1, dailyReward, dailyReward, result.coins - dailyReward, result.coins, "æ¯æ—¥ç™»å½•å¥–åŠ± (" .. today .. ")")

    return {
        success = true,
        message = "æ¯æ—¥å¥–åŠ±é¢†å–æˆåŠŸ",
        canClaim = true,
        rewardAmount = dailyReward,
        totalRewards = dailyReward,
        rewardedDays = 1,
        membershipType = "monthly"
    }
end

-- ==============================================
-- ç³»ç»Ÿé…ç½®ç›¸å…³
-- ==============================================

-- è·å–ç³»ç»Ÿé…ç½®
function UserDataService.getSystemConfig(configKey)
    local config = DataStoreManager.getSystemConfig(configKey)
    return config and config.value or nil
end

-- è·å–å‡ºå”®æ¯”ç‡
function UserDataService.getSellRate()
    return UserDataService.getSystemConfig("sell_rate") or "0.8"
end

-- ç«‹å³å‘é€å½“æ—¥ä¼šå‘˜å¥–åŠ±ï¼ˆè´­ä¹°ä¼šå‘˜æˆ–ç®¡ç†å‘˜ä¿®æ”¹ä¼šå‘˜åè°ƒç”¨ï¼‰
function UserDataService.claimTodayMembershipReward(userId)
    userId = tostring(userId)

    -- è·å–ç”¨æˆ·æ•°æ®å’Œä¼šå‘˜çŠ¶æ€
    local membershipStatus = UserDataService.getMembershipStatus(userId)

    -- æ£€æŸ¥è·å–ä¼šå‘˜çŠ¶æ€æ˜¯å¦å‡ºé”™
    if membershipStatus.error then
        warn("âš ï¸ [ç«‹å³å¥–åŠ±] è·å–ä¼šå‘˜çŠ¶æ€å¤±è´¥:", membershipStatus.error)
        return {
            success = false,
            message = "è·å–ä¼šå‘˜çŠ¶æ€å¤±è´¥: " .. membershipStatus.error,
            totalRewards = 0
        }
    end

    if not membershipStatus.isValid then
        return {
            success = false,
            message = "æ²¡æœ‰æœ‰æ•ˆçš„ä¼šå‘˜èµ„æ ¼",
            totalRewards = 0
        }
    end

    local today = os.date("%Y-%m-%d")
    local dailyReward = membershipStatus.dailyReward

    -- æ£€æŸ¥ä»Šæ—¥æ˜¯å¦å·²é¢†å–
    local rewardsKey = "daily_rewards_" .. userId
    local rewardHistory = DataStoreManager.safeGetAsync("DAILY_REWARDS", rewardsKey, {})

    -- æ£€æŸ¥ä»Šæ—¥æ˜¯å¦å·²é¢†å–
    for _, record in ipairs(rewardHistory) do
        if record.date == today then
            return {
                success = false,
                message = "ä»Šæ—¥å¥–åŠ±å·²é¢†å–",
                alreadyClaimed = true,
                totalRewards = 0
            }
        end
    end

    -- åŸå­æ›´æ–°ç”¨æˆ·é‡‘å¸
    local success, result = DataStoreManager.safeUpdateAsync("USERS", userId, function(currentData)
        if not currentData then
            error("ç”¨æˆ·ä¸å­˜åœ¨")
        end

        local coinsBefore = currentData.coins
        currentData.coins = currentData.coins + dailyReward
        currentData.updatedAt = os.time()

        return currentData
    end)

    if not success then
        return {
            success = false,
            message = "å¥–åŠ±é¢†å–å¤±è´¥",
            totalRewards = 0
        }
    end

    -- è®°å½•æ¯æ—¥å¥–åŠ±
    local success2 = DataStoreManager.safeUpdateAsync("DAILY_REWARDS", rewardsKey, function(currentData)
        if not currentData then
            currentData = {}
        end

        table.insert(currentData, {
            date = today,
            reward = dailyReward,
            timestamp = os.time(),
            membershipId = membershipStatus.membershipId
        })

        return currentData
    end)

    if success2 then
        -- è®°å½•æ¯æ—¥å¥–åŠ±äº¤æ˜“
        UserDataService.addTransactionRecord(userId, "daily_reward", "daily_membership_reward", 1, dailyReward, dailyReward, result.coins - dailyReward, result.coins, "ä¼šå‘˜æ¯æ—¥å¥–åŠ±")

        return {
            success = true,
            message = "æ¯æ—¥å¥–åŠ±é¢†å–æˆåŠŸ",
            totalRewards = dailyReward,
            newBalance = result.coins
        }
    else
        return {
            success = false,
            message = "å¥–åŠ±è®°å½•å¤±è´¥ï¼Œä½†é‡‘å¸å·²å‘æ”¾",
            totalRewards = dailyReward,
            newBalance = result.coins
        }
    end
end

print("ğŸ‘¤ ç”¨æˆ·æ•°æ®æœåŠ¡å·²åŠ è½½")

return UserDataService
