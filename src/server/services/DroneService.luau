-- æ— äººæœºç³»ç»ŸæœåŠ¡ç«¯æ¨¡å—
-- å¤„ç†æ— äººæœºçš„ç”Ÿæˆã€æ§åˆ¶ã€æ”»å‡»å’Œé”€æ¯é€»è¾‘

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local DroneService = {}

-- ç­‰å¾…æ¨¡å—
local SharedModules = ReplicatedStorage:WaitForChild("SharedModules")
local Config = require(SharedModules:WaitForChild("Config"))
local Events = require(SharedModules:WaitForChild("ShopEvents"))

-- ä½¿ç”¨ç»Ÿä¸€çš„é…ç½®
local DroneConfig = Config.DRONE_CONFIG

-- æ´»è·ƒæ— äººæœºç®¡ç†
local activeDrones = {} -- [player] = droneData

-- å»¶è¿ŸåŠ è½½TargetServiceï¼Œé¿å…å¾ªç¯ä¾èµ–
local TargetService = nil

-- è·å–TargetServiceï¼ˆå»¶è¿Ÿåˆå§‹åŒ–ï¼‰
local function getTargetService()
    if not TargetService then
        local success, result = pcall(function()
            local ServerScriptService = game:GetService("ServerScriptService")
            local serverFolder = ServerScriptService:FindFirstChild("Server")
            if serverFolder then
                local servicesFolder = serverFolder:FindFirstChild("services")
                if servicesFolder and servicesFolder:FindFirstChild("TargetService") then
                    return require(servicesFolder.TargetService)
                end
            end
            return nil
        end)
        if success and result then
            TargetService = result
        else
            warn("âŒ DroneService: æ— æ³•åŠ è½½ TargetService - " .. tostring(result))
        end
    end
    return TargetService
end

-- ==============================================
-- å†…éƒ¨å·¥å…·å‡½æ•°
-- ==============================================

local function log(message, ...)
    if Config and Config.log then
        Config.log("[æœåŠ¡ç«¯]", message, ...)
    else
        -- æ ‡å‡†æ—¥å¿—å‡½æ•°
        Config.log("[æœåŠ¡ç«¯]", message, ...)
    end
end

-- åˆ›å»ºæ”»å‡»ç‰¹æ•ˆ
local function createAttackEffect(startPos, endPos)
    if not Config.DRONE_CONFIG.EFFECTS.ATTACK_EFFECT then return end

    -- åˆ›å»ºæ¿€å…‰æŸç‰¹æ•ˆ
    local beam = Instance.new("Beam")
    local attachment1 = Instance.new("Attachment")
    local attachment2 = Instance.new("Attachment")

    -- åˆ›å»ºä¸´æ—¶éƒ¨ä»¶æ¥æ‰¿è½½attachment
    local part1 = Instance.new("Part")
    part1.Anchored = true
    part1.CanCollide = false
    part1.Transparency = 1
    part1.Size = Vector3.new(0.1, 0.1, 0.1)
    part1.Position = startPos
    part1.Parent = workspace

    local part2 = Instance.new("Part")
    part2.Anchored = true
    part2.CanCollide = false
    part2.Transparency = 1
    part2.Size = Vector3.new(0.1, 0.1, 0.1)
    part2.Position = endPos
    part2.Parent = workspace

    attachment1.Parent = part1
    attachment2.Parent = part2

    beam.Attachment0 = attachment1
    beam.Attachment1 = attachment2
    beam.Color = ColorSequence.new(Config.DRONE_CONFIG.EFFECTS.ATTACK_EFFECT.BEAM_COLOR)
    beam.Width0 = Config.DRONE_CONFIG.EFFECTS.ATTACK_EFFECT.BEAM_WIDTH
    beam.Width1 = Config.DRONE_CONFIG.EFFECTS.ATTACK_EFFECT.BEAM_WIDTH
    beam.Parent = part1

    -- è‡ªåŠ¨æ¸…ç†
    Debris:AddItem(part1, Config.DRONE_CONFIG.EFFECTS.ATTACK_EFFECT.BEAM_DURATION)
    Debris:AddItem(part2, Config.DRONE_CONFIG.EFFECTS.ATTACK_EFFECT.BEAM_DURATION)
end

-- åˆ›å»ºçˆ†ç‚¸ç‰¹æ•ˆ
local function createExplosionEffect(position)
    if not Config.DRONE_CONFIG.EFFECTS.EXPLOSION_EFFECT then return end

    -- åˆ›å»ºçˆ†ç‚¸æ•ˆæœå®¹å™¨
    local effectPart = Instance.new("Part")
    effectPart.Name = "ExplosionEffect"
    effectPart.Anchored = true
    effectPart.CanCollide = false
    effectPart.Transparency = 1
    effectPart.Size = Vector3.new(0.1, 0.1, 0.1)
    effectPart.Position = position
    effectPart.Parent = workspace

    -- åˆ›å»ºçˆ†ç‚¸å…‰çƒ
    local explosionBall = Instance.new("Part")
    explosionBall.Name = "ExplosionBall"
    explosionBall.Anchored = true
    explosionBall.CanCollide = false
    explosionBall.Material = Enum.Material.ForceField
    explosionBall.BrickColor = BrickColor.new("Bright orange")
    explosionBall.Shape = Enum.PartType.Ball
    explosionBall.Size = Vector3.new(0.1, 0.1, 0.1)
    explosionBall.Position = position
    explosionBall.Parent = effectPart

    -- æ·»åŠ å‘å…‰æ•ˆæœ
    local pointLight = Instance.new("PointLight")
    pointLight.Color = Color3.fromRGB(255, 165, 0)
    pointLight.Brightness = 5
    pointLight.Range = 15
    pointLight.Parent = explosionBall

    -- åˆ›å»ºç²’å­æ•ˆæœ
    local attachment = Instance.new("Attachment")
    attachment.Parent = explosionBall

    -- ç«èŠ±ç²’å­
    local sparkParticles = Instance.new("ParticleEmitter")
    sparkParticles.Parent = attachment
    sparkParticles.Texture = "rbxasset://textures/particles/sparkles_main.dds"
    sparkParticles.Lifetime = NumberRange.new(0.3, 0.8)
    sparkParticles.Rate = 200
    sparkParticles.SpreadAngle = Vector2.new(360, 360)
    sparkParticles.Speed = NumberRange.new(10, 25)
    sparkParticles.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 0)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 165, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))
    }
    sparkParticles.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(0.5, 1),
        NumberSequenceKeypoint.new(1, 0)
    }

    -- çƒŸé›¾ç²’å­
    local smokeParticles = Instance.new("ParticleEmitter")
    smokeParticles.Parent = attachment
    smokeParticles.Texture = "rbxasset://textures/particles/smoke_main.dds"
    smokeParticles.Lifetime = NumberRange.new(1, 2)
    smokeParticles.Rate = 50
    smokeParticles.SpreadAngle = Vector2.new(45, 45)
    smokeParticles.Speed = NumberRange.new(5, 15)
    smokeParticles.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 100, 100)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 50))
    }
    smokeParticles.Size = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(0.5, 2),
        NumberSequenceKeypoint.new(1, 3)
    }
    smokeParticles.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(1, 1)
    }

    -- çˆ†ç‚¸çƒæ‰©å±•åŠ¨ç”»
    local expandTween = TweenService:Create(
        explosionBall,
        TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Size = Vector3.new(8, 8, 8), Transparency = 1}
    )

    -- å…‰çº¿è¡°å‡åŠ¨ç”»
    local lightTween = TweenService:Create(
        pointLight,
        TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Brightness = 0, Range = 5}
    )

    -- æ’­æ”¾åŠ¨ç”»
    expandTween:Play()
    lightTween:Play()

    -- ä½¿ç”¨spawnæ¥å¼‚æ­¥åœæ­¢ç²’å­å‘å°„
    spawn(function()
        wait(0.1)
        sparkParticles.Enabled = false
        smokeParticles.Enabled = false
    end)

    -- æ¸…ç†æ•ˆæœ
    Debris:AddItem(effectPart, 3)

    log("åˆ›å»ºçˆ†ç‚¸ç‰¹æ•ˆäºä½ç½®:", position)
end

-- åˆ›å»ºç”Ÿæˆç‰¹æ•ˆ
local function createSpawnEffect(position)
    if not Config.DRONE_CONFIG.EFFECTS.SPAWN_EFFECT then return end

    -- åˆ›å»ºç²’å­å‘å°„å™¨
    local effectPart = Instance.new("Part")
    effectPart.Anchored = true
    effectPart.CanCollide = false
    effectPart.Transparency = 1
    effectPart.Size = Vector3.new(1, 1, 1)
    effectPart.Position = position
    effectPart.Parent = workspace

    local attachment = Instance.new("Attachment")
    attachment.Parent = effectPart

    local particles = Instance.new("ParticleEmitter")
    particles.Parent = attachment
    particles.Enabled = true
    particles.Lifetime = NumberRange.new(Config.DRONE_CONFIG.EFFECTS.SPAWN_EFFECT.LIFETIME)
    particles.Rate = Config.DRONE_CONFIG.EFFECTS.SPAWN_EFFECT.PARTICLE_COUNT
    particles.Color = ColorSequence.new(Config.DRONE_CONFIG.EFFECTS.SPAWN_EFFECT.COLOR)
    particles.VelocityInheritance = 0.5
    particles.Speed = NumberRange.new(5, 15)

    -- åœæ­¢å‘å°„å¹¶æ¸…ç†
    spawn(function()
        wait(0.5)
        particles.Enabled = false
        Debris:AddItem(effectPart, Config.DRONE_CONFIG.EFFECTS.SPAWN_EFFECT.LIFETIME + 1)
    end)
end

-- å°è¯•ä»å•ä¸ªæ¨¡å‹IDåŠ è½½æ— äººæœº
local function tryLoadModelFromId(assetId)
    -- æå–çº¯æ•°å­—IDï¼ˆå»æ‰rbxassetid://å‰ç¼€ï¼‰
    local numericId = assetId
    if string.find(assetId, "rbxassetid://") then
        numericId = string.gsub(assetId, "rbxassetid://", "")
    end

    -- è½¬æ¢ä¸ºæ•°å­—
    local assetNumber = tonumber(numericId)
    if not assetNumber then
        log("æ— æ•ˆçš„èµ„äº§IDæ ¼å¼ï¼š" .. assetId)
        return nil
    end

    local success, result = pcall(function()
        local insertService = game:GetService("InsertService")
        return insertService:LoadAsset(assetNumber)
    end)

    if success and result then
        log("âœ… æˆåŠŸä»ç½‘ç»œåŠ è½½æ¨¡å‹ï¼š" .. assetId .. " (æ•°å­—ID: " .. assetNumber .. ")")
        log("ğŸ“¦ æ¨¡å‹ç±»å‹ï¼š" .. result.ClassName)
        log("ğŸ“‚ æ¨¡å‹å­å¯¹è±¡æ•°é‡ï¼š" .. #result:GetChildren())

        -- æ‰“å°æ‰€æœ‰å­å¯¹è±¡ä¿¡æ¯ç”¨äºè°ƒè¯•
        for i, child in pairs(result:GetChildren()) do
            log("  â””â”€ å­å¯¹è±¡" .. i .. "ï¼š" .. child.Name .. " (" .. child.ClassName .. ")")
        end

        -- æŸ¥æ‰¾æ¨¡å‹ä¸­çš„æ— äººæœº
        for _, child in pairs(result:GetChildren()) do
            if child:IsA("Model") and child.Name ~= "Model" then
                log("æ‰¾åˆ°æ¨¡å‹å­å¯¹è±¡ï¼š" .. child.Name)
                -- æ‰¾åˆ°æ— äººæœºæ¨¡å‹ï¼Œè¿›è¡Œè®¾ç½®
                local drone = child:Clone()
                result:Destroy()

                -- ç¡®ä¿æ— äººæœºæœ‰PrimaryPart
                if not drone.PrimaryPart then
                    log("æ¨¡å‹æ²¡æœ‰PrimaryPartï¼Œå°è¯•æŸ¥æ‰¾ä¸»è¦éƒ¨ä»¶...")
                    -- å¯»æ‰¾ä¸»è¦éƒ¨ä»¶
                    local mainPart = drone:FindFirstChild("Body") or drone:FindFirstChild("Main") or drone:FindFirstChildOfClass("Part")
                    if mainPart then
                        drone.PrimaryPart = mainPart
                        log("è®¾ç½®PrimaryPartä¸ºï¼š" .. mainPart.Name)
                    else
                        log("æœªæ‰¾åˆ°åˆé€‚çš„ä¸»è¦éƒ¨ä»¶")
                    end
                end

                -- å¦‚æœæœ‰PrimaryPartï¼Œæ·»åŠ ç§»åŠ¨æ§åˆ¶
                if drone.PrimaryPart then
                    local body = drone.PrimaryPart

                    -- ç¡®ä¿éƒ¨ä»¶è®¾ç½®æ­£ç¡®
                    body.Anchored = false
                    body.CanCollide = false

                    -- æ·»åŠ æˆ–æ›´æ–°BodyPosition
                    local bodyPosition = body:FindFirstChild("BodyPosition")
                    if not bodyPosition then
                        bodyPosition = Instance.new("BodyPosition")
                        bodyPosition.Parent = body
                    end
                    bodyPosition.MaxForce = Vector3.new(8000, 8000, 8000)
                    bodyPosition.D = 3000
                    bodyPosition.P = 12000

                    log("æˆåŠŸé…ç½®æ— äººæœºæ¨¡å‹ï¼š" .. assetId .. "ï¼ŒPrimaryPartï¼š" .. body.Name)
                    return drone
                else
                    log("æ¨¡å‹æ²¡æœ‰æœ‰æ•ˆçš„PrimaryPartï¼Œè·³è¿‡")
                end
            end
        end

        -- å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­æ¨¡å‹ï¼Œå°è¯•ç›´æ¥ä½¿ç”¨åŠ è½½çš„æ¨¡å‹
        if result:IsA("Model") then
            log("å°è¯•ç›´æ¥ä½¿ç”¨åŠ è½½çš„æ¨¡å‹ä½œä¸ºæ— äººæœº")
            local drone = result:Clone()
            result:Destroy()

            -- ç¡®ä¿æ— äººæœºæœ‰PrimaryPart
            if not drone.PrimaryPart then
                log("ç›´æ¥æ¨¡å‹æ²¡æœ‰PrimaryPartï¼Œå°è¯•æŸ¥æ‰¾ä¸»è¦éƒ¨ä»¶...")
                local mainPart = drone:FindFirstChild("Body") or drone:FindFirstChild("Main") or drone:FindFirstChildOfClass("Part")
                if mainPart then
                    drone.PrimaryPart = mainPart
                    log("è®¾ç½®PrimaryPartä¸ºï¼š" .. mainPart.Name)
                end
            end

            if drone.PrimaryPart then
                local body = drone.PrimaryPart
                body.Anchored = false
                body.CanCollide = false

                local bodyPosition = body:FindFirstChild("BodyPosition")
                if not bodyPosition then
                    bodyPosition = Instance.new("BodyPosition")
                    bodyPosition.Parent = body
                end
                bodyPosition.MaxForce = Vector3.new(8000, 8000, 8000)
                bodyPosition.D = 3000
                bodyPosition.P = 12000

                log("æˆåŠŸé…ç½®ç›´æ¥æ¨¡å‹ï¼š" .. assetId)
                return drone
            end
        end

        result:Destroy()
        log("æ¨¡å‹" .. assetId .. "ç»“æ„ä¸ç¬¦åˆè¦æ±‚ï¼Œæ— æ³•ä½¿ç”¨")
    else
        local errorMsg = result or "æœªçŸ¥é”™è¯¯"
        log("âŒ æ— æ³•ä»ç½‘ç»œåŠ è½½æ¨¡å‹IDï¼š" .. assetId .. " (æ•°å­—ID: " .. (assetNumber or "æ— æ•ˆ") .. ")ï¼Œé”™è¯¯ï¼š" .. tostring(errorMsg))
    end

    return nil
end

-- åŠ è½½æ— äººæœºæ¨¡å‹
local function loadDroneModel()
    -- é¦–å…ˆå°è¯•åŠ è½½ä¸»è¦æ¨¡å‹
    local drone = tryLoadModelFromId(Config.DRONE_CONFIG.MODEL.ASSET_ID)
    if drone then
        return drone
    end

    -- å¦‚æœä¸»è¦æ¨¡å‹å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æ¨¡å‹
    if Config.DRONE_CONFIG.MODEL.FALLBACK_ASSET_IDS then
        for _, fallbackId in ipairs(Config.DRONE_CONFIG.MODEL.FALLBACK_ASSET_IDS) do
            if fallbackId ~= Config.DRONE_CONFIG.MODEL.ASSET_ID then -- é¿å…é‡å¤å°è¯•ä¸»è¦æ¨¡å‹
                drone = tryLoadModelFromId(fallbackId)
                if drone then
                    return drone
                end
            end
        end
    end

    -- æ‰€æœ‰å¤–éƒ¨æ¨¡å‹éƒ½å¤±è´¥ï¼Œä½¿ç”¨å†…ç½®å¤‡ç”¨æ¨¡å‹
    log("æ‰€æœ‰å¤–éƒ¨æ¨¡å‹éƒ½æ— æ³•åŠ è½½ï¼Œä½¿ç”¨å†…ç½®å¤‡ç”¨æ¨¡å‹")
    local drone = Instance.new("Model")
    drone.Name = "Drone"

    -- ä¸»ä½“
    local body = Instance.new("Part")
    body.Name = "Body"
    body.Material = Enum.Material.ForceField
    body.BrickColor = BrickColor.new("Bright blue")
    body.Shape = Enum.PartType.Ball
    body.Size = Vector3.new(3, 3, 3)
    body.Anchored = false
    body.CanCollide = false
    body.TopSurface = Enum.SurfaceType.Smooth
    body.BottomSurface = Enum.SurfaceType.Smooth
    body.Parent = drone

    -- æ·»åŠ å‘å…‰æ•ˆæœ
    local pointLight = Instance.new("PointLight")
    pointLight.Color = Color3.fromRGB(0, 162, 255)
    pointLight.Brightness = 2
    pointLight.Range = 10
    pointLight.Parent = body

    -- æ·»åŠ BodyPositionç”¨äºä½ç½®æ§åˆ¶ï¼ˆæ›´é€‚åˆæ— äººæœºçš„æ‚¬åœç§»åŠ¨ï¼‰
    local bodyPosition = Instance.new("BodyPosition")
    bodyPosition.MaxForce = Vector3.new(8000, 8000, 8000)
    bodyPosition.Position = Vector3.new(0, 0, 0)
    bodyPosition.D = 3000 -- å¢åŠ é˜»å°¼ä»¥å‡å°‘éœ‡è¡
    bodyPosition.P = 12000 -- å¢åŠ åŠŸç‡ä»¥æé«˜å“åº”é€Ÿåº¦
    bodyPosition.Parent = body

    -- æ·»åŠ BodyAngularVelocityç”¨äºç¨³å®šæ—‹è½¬
    local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
    bodyAngularVelocity.MaxTorque = Vector3.new(4000, 4000, 4000)
    bodyAngularVelocity.AngularVelocity = Vector3.new(0, 0, 0)
    bodyAngularVelocity.Parent = body

    -- PrimaryPartè®¾ç½®
    drone.PrimaryPart = body

    return drone
end

-- æŸ¥æ‰¾æ”»å‡»ç›®æ ‡ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼šç©å®¶ > NPC > é¶å­ï¼‰
-- æ–°å¢å‚æ•°ï¼šcurrentTarget ç”¨äºç›®æ ‡é”å®šé€»è¾‘
local function findNearestTarget(dronePosition, attackRange, ownerPlayer, currentTarget)
    local targets = {
        players = {},
        npcs = {},
        targets = {}
    }

    -- ç›®æ ‡é”å®šæœºåˆ¶ï¼šå¦‚æœå½“å‰ç›®æ ‡ä»ç„¶æœ‰æ•ˆä¸”åœ¨èŒƒå›´å†…ï¼Œä¼˜å…ˆä¿æŒé”å®š
    if currentTarget and currentTarget.target then
        local target = currentTarget.target
        local isValid = false
        local currentDistance = 0

        -- æ£€æŸ¥å½“å‰ç›®æ ‡æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
        if currentTarget.type == "player" then
            if target.Parent and Players:GetPlayerFromCharacter(target) and target:FindFirstChild("HumanoidRootPart") then
                currentDistance = (target.HumanoidRootPart.Position - dronePosition).Magnitude
                isValid = currentDistance <= attackRange * 1.2  -- ç»™äºˆ20%çš„é¢å¤–èŒƒå›´å®¹å¿åº¦
            end
        elseif currentTarget.type == "npc" then
            if target and target.Parent and target:FindFirstChild("HumanoidRootPart") and target:FindFirstChild("Humanoid") then
                currentDistance = (target.HumanoidRootPart.Position - dronePosition).Magnitude
                isValid = currentDistance <= attackRange * 1.2
            end
        elseif currentTarget.type == "target" then
            if target and target.Parent and target.Transparency == 0 then
                currentDistance = (target.Position - dronePosition).Magnitude
                isValid = currentDistance <= attackRange * 1.2
            end
        end

        -- å¦‚æœå½“å‰ç›®æ ‡ä»ç„¶æœ‰æ•ˆï¼Œç»§ç»­é”å®šå®ƒï¼ˆé™¤éæœ‰æ›´é«˜ä¼˜å…ˆçº§çš„ç›®æ ‡å‡ºç°ï¼‰
        if isValid then
            -- åªæœ‰å½“å‘ç°æ›´é«˜ä¼˜å…ˆçº§çš„ç›®æ ‡æ—¶æ‰åˆ‡æ¢
            local currentPriority = Config.DRONE_CONFIG.TARGET_PRIORITY[string.upper(currentTarget.type .. "S")] or 999

            -- å¿«é€Ÿæ£€æŸ¥æ˜¯å¦æœ‰æ›´é«˜ä¼˜å…ˆçº§çš„ç›®æ ‡
            local hasHigherPriorityTarget = false

            -- æ£€æŸ¥ç©å®¶ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
            if currentPriority > Config.DRONE_CONFIG.TARGET_PRIORITY.PLAYERS then
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= ownerPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (player.Character.HumanoidRootPart.Position - dronePosition).Magnitude
                        if distance <= attackRange then
                            hasHigherPriorityTarget = true
                            break
                        end
                    end
                end
            end

            -- å¦‚æœæ²¡æœ‰æ›´é«˜ä¼˜å…ˆçº§ç›®æ ‡ï¼Œä¿æŒå½“å‰é”å®š
            if not hasHigherPriorityTarget then
                return currentTarget.target, currentTarget.type, currentTarget.height
            end
        end
    end

    -- æ”¶é›†æ‰€æœ‰å¯èƒ½çš„ç›®æ ‡

    -- 1. æŸ¥æ‰¾å…¶ä»–ç©å®¶ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= ownerPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - dronePosition).Magnitude
            if distance <= attackRange then
                table.insert(targets.players, {
                    target = player.Character,
                    distance = distance,
                    type = "player",
                    priority = Config.DRONE_CONFIG.TARGET_PRIORITY.PLAYERS
                })
            end
        end
    end

    -- 2. æŸ¥æ‰¾NPCï¼ˆä¸­ç­‰ä¼˜å…ˆçº§ï¼‰
    for _, obj in pairs(workspace:GetChildren()) do
        if obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj:FindFirstChild("HumanoidRootPart") then
            -- æ£€æŸ¥æ˜¯å¦æ˜¯ç©å®¶è§’è‰²
            local isPlayerCharacter = false
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character == obj then
                    isPlayerCharacter = true
                    break
                end
            end

            if not isPlayerCharacter then
                local distance = (obj.HumanoidRootPart.Position - dronePosition).Magnitude
                if distance <= attackRange then
                    table.insert(targets.npcs, {
                        target = obj,
                        distance = distance,
                        type = "npc",
                        priority = Config.DRONE_CONFIG.TARGET_PRIORITY.NPCS
                    })
                end
            end
        end
    end

    -- 3. æŸ¥æ‰¾é¶å­ï¼ˆæœ€ä½ä¼˜å…ˆçº§ï¼‰
    local targetsFolder = workspace:FindFirstChild("Targets")
    if targetsFolder then
        for _, targetModel in pairs(targetsFolder:GetChildren()) do
            if targetModel:IsA("Model") then
                local basePart = targetModel:FindFirstChild("Base")
                if basePart and basePart:IsA("Part") and basePart.Transparency == 0 then
                    local distance = (basePart.Position - dronePosition).Magnitude
                    if distance <= attackRange then
                        table.insert(targets.targets, {
                            target = basePart,
                            distance = distance,
                            type = "target",
                            priority = Config.DRONE_CONFIG.TARGET_PRIORITY.TARGETS,
                            height = basePart.Position.Y  -- ä¿å­˜é¶å­é«˜åº¦ä¿¡æ¯
                        })
                    end
                end
            end
        end
    end

    -- æŒ‰ä¼˜å…ˆçº§é€‰æ‹©ç›®æ ‡
    local allTargets = {}

    -- æ·»åŠ æ‰€æœ‰ç›®æ ‡åˆ°ç»Ÿä¸€åˆ—è¡¨
    for _, targetList in pairs(targets) do
        for _, targetData in pairs(targetList) do
            table.insert(allTargets, targetData)
        end
    end

    -- æŒ‰ä¼˜å…ˆçº§å’Œè·ç¦»æ’åº
    table.sort(allTargets, function(a, b)
        if a.priority ~= b.priority then
            return a.priority < b.priority  -- ä¼˜å…ˆçº§è¶Šå°è¶Šä¼˜å…ˆ
        else
            return a.distance < b.distance  -- åŒä¼˜å…ˆçº§æŒ‰è·ç¦»æ’åº
        end
    end)

    -- è¿”å›æœ€ä¼˜ç›®æ ‡
    if #allTargets > 0 then
        local bestTarget = allTargets[1]
        return bestTarget.target, bestTarget.type, bestTarget.height
    end

    return nil, "none", nil
end

-- æ— äººæœºæ”»å‡»ç›®æ ‡
local function attackTarget(drone, target, targetType)
    local body = drone.PrimaryPart
    if not body or not target then
        return false
    end

    -- éªŒè¯ç›®æ ‡æ˜¯å¦ä»ç„¶å­˜åœ¨
    if targetType == "target" then
        -- æ£€æŸ¥é¶å­æ˜¯å¦è¿˜åœ¨Targetsæ–‡ä»¶å¤¹ä¸­å¹¶ä¸”å¯è§ï¼ˆé€æ˜åº¦ä¸º0è¡¨ç¤ºå¯è§ï¼Œé€æ˜åº¦ä¸º1è¡¨ç¤ºéšè—ï¼‰
        local targetsFolder = workspace:FindFirstChild("Targets")
        local targetModel = target.Parent
        if not targetsFolder or not targetModel or targetModel.Parent ~= targetsFolder or target.Transparency == 1 then
            log("ç›®æ ‡é¶å­å·²æ¶ˆå¤±æˆ–è¢«éšè—ï¼Œå–æ¶ˆæ”»å‡»")
            return false
        end
    else
        -- æ£€æŸ¥ç©å®¶æˆ–NPCæ˜¯å¦ä»ç„¶æœ‰æ•ˆ
        if not target.Parent or not target:FindFirstChild("HumanoidRootPart") then
            log("ç›®æ ‡è§’è‰²å·²æ¶ˆå¤±ï¼Œå–æ¶ˆæ”»å‡»")
            return false
        end
    end

    local targetPos
    local dronePos = body.Position

    -- æ ¹æ®ç›®æ ‡ç±»å‹è·å–ä½ç½®
    if targetType == "target" then
        -- é¶å­æ˜¯Partå¯¹è±¡
        targetPos = target.Position
    else
        -- ç©å®¶æˆ–NPCæœ‰HumanoidRootPart
        if not target:FindFirstChild("HumanoidRootPart") then
            return false
        end
        targetPos = target.HumanoidRootPart.Position
    end

    -- åˆ›å»ºæ”»å‡»ç‰¹æ•ˆ
    createAttackEffect(dronePos, targetPos)

    -- æ ¹æ®ç›®æ ‡ç±»å‹å¤„ç†ä¼¤å®³
    if targetType == "target" then
        -- æ”»å‡»é¶å­ - é€šè¿‡TargetServiceå¤„ç†
        local targetModel = target.Parent  -- targetæ˜¯Baseéƒ¨ä»¶ï¼Œå…¶çˆ¶çº§æ˜¯Model
        local targetId = targetModel.Name
        local ownerName = drone.Owner.Value.Name

        -- ç›´æ¥åœ¨æœåŠ¡ç«¯å¤„ç†é¶å­ä¼¤å®³ - è·å–TargetService
        local TargetServiceInstance = getTargetService()

        if TargetServiceInstance and TargetServiceInstance.damageTarget then
            local destroyed = TargetServiceInstance.damageTarget(targetId, Config.DRONE_CONFIG.ATTACK_DAMAGE, ownerName)
            log("ğŸ”¥ æ— äººæœºæ”»å‡»é¶å­:", targetId, "é€ æˆä¼¤å®³:", Config.DRONE_CONFIG.ATTACK_DAMAGE, destroyed and "(è¢«æ‘§æ¯)" or "")

            -- å¦‚æœé¶å­è¢«æ‘§æ¯ï¼Œåˆ›å»ºçˆ†ç‚¸æ•ˆæœ
            if destroyed then
                createExplosionEffect(targetPos)
            end
        else
            log("âŒ æ— æ³•è·å–TargetServiceæ¥å¤„ç†é¶å­ä¼¤å®³ - æœåŠ¡å¯èƒ½æœªåˆå§‹åŒ–æˆ–æ–¹æ³•ä¸å­˜åœ¨")
        end
    else
        -- æ”»å‡»ç©å®¶æˆ–NPC
        local humanoid = target:FindFirstChild("Humanoid")
        if humanoid then
            local oldHealth = humanoid.Health
            humanoid.Health = humanoid.Health - Config.DRONE_CONFIG.ATTACK_DAMAGE
            log("æ”»å‡»ç›®æ ‡:", target.Name, "é€ æˆä¼¤å®³:", Config.DRONE_CONFIG.ATTACK_DAMAGE)

            -- å¦‚æœç›®æ ‡è¢«å‡»è´¥ï¼Œåˆ›å»ºçˆ†ç‚¸æ•ˆæœ
            if humanoid.Health <= 0 and oldHealth > 0 then
                createExplosionEffect(targetPos)
            end
        end
    end

    -- æ’­æ”¾æ”»å‡»éŸ³æ•ˆ
    local sound = Instance.new("Sound")
    sound.SoundId = Config.DRONE_CONFIG.SOUNDS.ATTACK
    sound.Volume = Config.DRONE_CONFIG.SOUNDS.VOLUME.ATTACK
    sound.Parent = body
    sound:Play()

    -- æ¸…ç†éŸ³æ•ˆ
    sound.Ended:Connect(function()
        sound:Destroy()
    end)

    return true
end

-- æ— äººæœºç§»åŠ¨é€»è¾‘ï¼ˆåŒ…å«é«˜åº¦æ§åˆ¶ï¼‰
local function updateDroneMovement(droneData)
    local drone = droneData.model
    local player = droneData.owner
    local mode = droneData.mode

    if not drone or not drone.PrimaryPart or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    local body = drone.PrimaryPart
    local bodyPosition = body:FindFirstChild("BodyPosition")
    if not bodyPosition then
        log("è­¦å‘Š: æ— äººæœºç¼ºå°‘BodyPositionç»„ä»¶")
        return
    end

    local playerPos = player.Character.HumanoidRootPart.Position
    local currentPos = body.Position
    local targetPos
    local targetHeight

    -- æ£€æŸ¥æ˜¯å¦æœ‰å½“å‰æ”»å‡»ç›®æ ‡æ¥è°ƒæ•´é«˜åº¦
    local currentTarget = droneData.currentTarget
    local targetSpecificHeight = nil

    if currentTarget and currentTarget.type == "target" and currentTarget.height then
        -- å¦‚æœæ­£åœ¨æ”»å‡»é¶å­ï¼Œè°ƒæ•´åˆ°é¶å­é«˜åº¦
        targetSpecificHeight = currentTarget.height + Config.DRONE_CONFIG.HEIGHT_CONTROL.TARGET_OFFSET
    end

    if mode == Config.DRONE_CONFIG.MODES.FOLLOW then
        -- è·Ÿéšæ¨¡å¼ï¼šæ ¹æ®ç©å®¶æœå‘æ™ºèƒ½è·Ÿéš
        local humanoidRootPart = player.Character.HumanoidRootPart
        local lookDirection = humanoidRootPart.CFrame.LookVector

        -- è®¡ç®—è·Ÿéšä½ç½®ï¼ˆåœ¨ç©å®¶èº«åä¸Šæ–¹ï¼‰
        local behindOffset = -lookDirection * Config.DRONE_CONFIG.FOLLOW_DISTANCE

        -- æ ¹æ®æ˜¯å¦æœ‰ç‰¹å®šç›®æ ‡å†³å®šé«˜åº¦
        if targetSpecificHeight then
            targetHeight = targetSpecificHeight
        else
            targetHeight = Config.DRONE_CONFIG.FOLLOW_HEIGHT
        end

        local heightOffset = Vector3.new(0, targetHeight, 0)
        targetPos = playerPos + behindOffset + heightOffset

        -- æ·»åŠ ä¸€äº›éšæœºåç§»ä»¥é¿å…è¿‡äºåƒµç¡¬çš„è·Ÿéš
        local randomIntensity = currentTarget and 0.5 or 1.0  -- æœ‰ç›®æ ‡æ—¶å‡å°‘éšæœºåç§»
        local randomOffset = Vector3.new(
            (math.random() - 0.5) * 2 * randomIntensity,
            (math.random() - 0.5) * 0.5 * randomIntensity,  -- å‡å°‘Yè½´éšæœºåç§»
            (math.random() - 0.5) * 2 * randomIntensity
        )
        targetPos = targetPos + randomOffset
    else
        -- é©»å®ˆæ¨¡å¼ï¼šä¿æŒåœ¨è®¾å®šçš„ä½ç½®
        if not droneData.guardPosition then
            -- å¦‚æœæ²¡æœ‰è®¾å®šé©»å®ˆä½ç½®ï¼Œä½¿ç”¨å½“å‰ä½ç½®
            droneData.guardPosition = currentPos
        end

        targetPos = droneData.guardPosition

        -- å¦‚æœæœ‰ç‰¹å®šç›®æ ‡ï¼Œè°ƒæ•´é©»å®ˆé«˜åº¦
        if targetSpecificHeight then
            targetPos = Vector3.new(targetPos.X, targetSpecificHeight, targetPos.Z)
        end
    end

    -- åº”ç”¨é«˜åº¦é™åˆ¶
    if Config.DRONE_CONFIG.HEIGHT_CONTROL.AUTO_ADJUST then
        targetPos = Vector3.new(
            targetPos.X,
            math.max(Config.DRONE_CONFIG.HEIGHT_CONTROL.MIN_HEIGHT,
                    math.min(Config.DRONE_CONFIG.HEIGHT_CONTROL.MAX_HEIGHT, targetPos.Y)),
            targetPos.Z
        )
    end

    -- æ›´æ–°ç›®æ ‡ä½ç½®
    bodyPosition.Position = targetPos

    -- è°ƒè¯•ä¿¡æ¯
    if Config.DEBUG and Config.DEBUG.VERBOSE_LOGGING then
        local distance = (currentPos - targetPos).Magnitude
        if distance > 1 then
            log("æ— äººæœºç§»åŠ¨:", player.Name, "æ¨¡å¼:", mode, "é«˜åº¦:", math.floor(targetPos.Y), "è·ç¦»ç›®æ ‡:", math.floor(distance), "studs")
        end
    end
end

-- ==============================================
-- æ— äººæœºç®¡ç†å‡½æ•°
-- ==============================================

function DroneService.spawnDrone(player: Player)
    -- æ£€æŸ¥ç©å®¶æ˜¯å¦å·²æœ‰æ— äººæœº
    if activeDrones[player] then
        return false, "æ‚¨å·²ç»æœ‰ä¸€ä¸ªæ´»è·ƒçš„æ— äººæœºäº†"
    end

    -- æ£€æŸ¥ç©å®¶è§’è‰²æ˜¯å¦å­˜åœ¨
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false, "æ— æ³•è·å–ç©å®¶ä½ç½®"
    end

    -- åŠ è½½æ— äººæœºæ¨¡å‹
    local droneModel = loadDroneModel()
    if not droneModel then
        return false, "æ— æ³•åŠ è½½æ— äººæœºæ¨¡å‹"
    end

    -- è®¾ç½®æ— äººæœºä½ç½®
    local playerPos = player.Character.HumanoidRootPart.Position
    local spawnPos = playerPos + Vector3.new(0, Config.DRONE_CONFIG.FOLLOW_HEIGHT, -Config.DRONE_CONFIG.FOLLOW_DISTANCE)

    droneModel:SetPrimaryPartCFrame(CFrame.new(spawnPos))
    droneModel.Parent = workspace

    -- åˆ›å»ºç”Ÿæˆç‰¹æ•ˆ
    createSpawnEffect(spawnPos)

    -- æ’­æ”¾ç”ŸæˆéŸ³æ•ˆï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
    pcall(function()
        local sound = Instance.new("Sound")
        sound.SoundId = Config.DRONE_CONFIG.SOUNDS.SPAWN
        sound.Volume = Config.DRONE_CONFIG.SOUNDS.VOLUME.SPAWN
        sound.Parent = droneModel.PrimaryPart

        local success = pcall(function()
            sound:Play()
        end)

        if not success then
            log("âš ï¸ ç”ŸæˆéŸ³æ•ˆæ’­æ”¾å¤±è´¥")
        end

        sound.Ended:Connect(function()
            sound:Destroy()
        end)
    end)

    -- æ·»åŠ Ownerå±æ€§åˆ°æ— äººæœºæ¨¡å‹
    local ownerValue = Instance.new("ObjectValue")
    ownerValue.Name = "Owner"
    ownerValue.Value = player
    ownerValue.Parent = droneModel

    -- åˆ›å»ºæ— äººæœºæ•°æ®
    local droneData = {
        model = droneModel,
        owner = player,
        mode = Config.DRONE_CONFIG.MODES.FOLLOW,
        spawnTime = tick(),
        lastAttackTime = 0,
        lastTargetSwitchTime = 0,  -- æ–°å¢ï¼šç›®æ ‡åˆ‡æ¢æ—¶é—´è®°å½•
        guardPosition = nil,
        currentTarget = nil  -- å½“å‰æ”»å‡»ç›®æ ‡ä¿¡æ¯
    }

    activeDrones[player] = droneData

    -- é€šçŸ¥å®¢æˆ·ç«¯
    Events.Drone.DroneSpawned:FireClient(player, true)

    log("ç©å®¶", player.Name, "å¬å”¤äº†æ— äººæœº")

    return true, "æ— äººæœºå·²å¬å”¤"
end

function DroneService.recallDrone(player: Player)
    local droneData = activeDrones[player]
    if not droneData then
        return false, "æ‚¨æ²¡æœ‰æ´»è·ƒçš„æ— äººæœº"
    end

    -- é”€æ¯æ— äººæœºæ¨¡å‹
    if droneData.model then
        droneData.model:Destroy()
    end

    -- æ¸…é™¤æ•°æ®
    activeDrones[player] = nil

    -- é€šçŸ¥å®¢æˆ·ç«¯
    Events.Drone.DroneRecalled:FireClient(player, true)

    log("ç©å®¶", player.Name, "æ”¶å›äº†æ— äººæœº")

    return true, "æ— äººæœºå·²æ”¶å›"
end

function DroneService.switchDroneMode(player: Player, newMode: string)
    local droneData = activeDrones[player]
    if not droneData then
        return false, "æ‚¨æ²¡æœ‰æ´»è·ƒçš„æ— äººæœº"
    end

    if newMode ~= Config.DRONE_CONFIG.MODES.FOLLOW and newMode ~= Config.DRONE_CONFIG.MODES.GUARD then
        return false, "æ— æ•ˆçš„æ¨¡å¼"
    end

    local oldMode = droneData.mode
    droneData.mode = newMode

    -- å¦‚æœåˆ‡æ¢åˆ°é©»å®ˆæ¨¡å¼ï¼Œè®°å½•å½“å‰ä½ç½®
    if newMode == Config.DRONE_CONFIG.MODES.GUARD and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local playerPos = player.Character.HumanoidRootPart.Position
        droneData.guardPosition = playerPos + Vector3.new(0, Config.DRONE_CONFIG.HOVER_HEIGHT, 0)
    end

    -- é€šçŸ¥å®¢æˆ·ç«¯
    Events.Drone.DroneModeChanged:FireClient(player, newMode, oldMode)

    log("ç©å®¶", player.Name, "å°†æ— äººæœºæ¨¡å¼ä»", oldMode, "åˆ‡æ¢åˆ°", newMode)

    return true, "æ¨¡å¼å·²åˆ‡æ¢åˆ°" .. (newMode == Config.DRONE_CONFIG.MODES.FOLLOW and "è·Ÿéšæ¨¡å¼" or "é©»å®ˆæ¨¡å¼")
end

function DroneService.getDroneInfo(player: Player)
    local droneData = activeDrones[player]
    if not droneData then
        return nil
    end

    local currentTime = tick()
    local timeRemaining = math.max(0, Config.DRONE_CONFIG.LIFETIME - (currentTime - droneData.spawnTime))

    return {
        mode = droneData.mode,
        timeRemaining = timeRemaining,
        isActive = timeRemaining > 0
    }
end

-- ==============================================
-- ä¸»å¾ªç¯å’Œäº‹ä»¶å¤„ç†
-- ==============================================

local function mainLoop()
    local currentTime = tick()

    for player, droneData in pairs(activeDrones) do
        -- æ£€æŸ¥æ— äººæœºæ˜¯å¦è¶…æ—¶
        local timeElapsed = currentTime - droneData.spawnTime
        if timeElapsed >= Config.DRONE_CONFIG.LIFETIME then
            droneData.model:Destroy()
            activeDrones[player] = nil

            -- é€šçŸ¥å®¢æˆ·ç«¯
            Events.Drone.DroneDestroyed:FireClient(player, "æ—¶é—´åˆ°æœŸ")
            log("ç©å®¶", player.Name, "çš„æ— äººæœºå› æ—¶é—´åˆ°æœŸè€Œé”€æ¯")
            continue
        end

        -- æ›´æ–°æ— äººæœºç§»åŠ¨
        updateDroneMovement(droneData)

        -- æ”»å‡»é€»è¾‘
        if (currentTime - droneData.lastAttackTime) >= Config.DRONE_CONFIG.ATTACK_INTERVAL then
            local dronePos = droneData.model.PrimaryPart.Position
            local target, targetType, targetHeight = findNearestTarget(dronePos, Config.DRONE_CONFIG.ATTACK_RANGE, player, droneData.currentTarget)

            if target then
                -- æ£€æŸ¥æ˜¯å¦åˆ‡æ¢äº†ç›®æ ‡
                local targetChanged = false
                if not droneData.currentTarget or droneData.currentTarget.target ~= target then
                    targetChanged = true
                    droneData.lastTargetSwitchTime = currentTime
                end

                -- æ›´æ–°å½“å‰ç›®æ ‡ä¿¡æ¯ï¼ˆç”¨äºé«˜åº¦æ§åˆ¶ï¼‰
                droneData.currentTarget = {
                    target = target,
                    type = targetType,
                    height = targetHeight
                }

                -- è®°å½•ç›®æ ‡åˆ‡æ¢
                if targetChanged then
                    local targetName = targetType == "target" and (target.Parent and target.Parent.Name or target.Name) or target.Name
                    log("ğŸ¯ æ— äººæœºåˆ‡æ¢ç›®æ ‡ï¼š", targetName, "ç±»å‹ï¼š", targetType)
                end

                local attackSuccess = attackTarget(droneData.model, target, targetType)
                if attackSuccess then
                    droneData.lastAttackTime = currentTime

                    -- é€šçŸ¥å®¢æˆ·ç«¯æ”»å‡»äº‹ä»¶
                    local targetName = targetType == "target" and (target.Parent and target.Parent.Name or target.Name) or target.Name
                    Events.Drone.DroneAttack:FireClient(player, targetName)
                    log("âœ… æ— äººæœºæ”»å‡»æˆåŠŸï¼šç±»å‹=" .. targetType .. ", ç›®æ ‡=" .. targetName ..
                        (targetHeight and (", é«˜åº¦=" .. math.floor(targetHeight)) or ""))
                else
                    -- æ”»å‡»å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç›®æ ‡å·²æ¶ˆå¤±ï¼Œé‡ç½®æ”»å‡»æ—¶é—´ä»¥ä¾¿ç«‹å³å¯»æ‰¾æ–°ç›®æ ‡
                    droneData.lastAttackTime = currentTime - Config.DRONE_CONFIG.ATTACK_INTERVAL + 0.1
                    droneData.currentTarget = nil  -- æ¸…é™¤æ— æ•ˆç›®æ ‡
                end
            else
                -- æ²¡æœ‰æ‰¾åˆ°ç›®æ ‡ï¼Œæ¸…é™¤å½“å‰ç›®æ ‡ä¿¡æ¯
                droneData.currentTarget = nil
            end
        end
    end
end

-- å¯åŠ¨ä¸»å¾ªç¯
local connection = RunService.Heartbeat:Connect(mainLoop)

-- ç©å®¶ç¦»å¼€æ—¶æ¸…ç†
Players.PlayerRemoving:Connect(function(player)
    if activeDrones[player] then
        if activeDrones[player].model then
            activeDrones[player].model:Destroy()
        end
        activeDrones[player] = nil
    end
end)

-- ==============================================
-- äº‹ä»¶è¿æ¥
-- ==============================================

Events.Drone.SpawnDrone.OnServerEvent:Connect(function(player)
    local success, message = DroneService.spawnDrone(player)
    -- å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å®¢æˆ·ç«¯åé¦ˆ
end)

Events.Drone.RecallDrone.OnServerEvent:Connect(function(player)
    local success, message = DroneService.recallDrone(player)
    -- å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å®¢æˆ·ç«¯åé¦ˆ
end)

Events.Drone.SwitchDroneMode.OnServerEvent:Connect(function(player, newMode)
    local success, message = DroneService.switchDroneMode(player, newMode)
    -- å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å®¢æˆ·ç«¯åé¦ˆ
end)

log("æ— äººæœºæœåŠ¡å·²å¯åŠ¨")

return DroneService
