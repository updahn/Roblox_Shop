-- æ™®é€šç”¨æˆ·æœåŠ¡æ¨¡å—
-- å¤„ç†ç”¨æˆ·è®¤è¯ã€æ•°æ®è·å–ã€è´­ä¹°/å‡ºå”®ç­‰åŸºç¡€åŠŸèƒ½

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local UserService = {}

-- ç­‰å¾…æ¨¡å—
local SharedModules = ReplicatedStorage:WaitForChild("SharedModules")
local Config = require(SharedModules:WaitForChild("Config"))
local Events = require(SharedModules:WaitForChild("ShopEvents"))
local DataService = require(script.Parent:WaitForChild("DataService"))

-- ç©å®¶ä¼šè¯ç®¡ç†
local playerSessions = {} -- å­˜å‚¨å·²ç™»å½•çš„ç©å®¶

-- ==============================================
-- å†…éƒ¨å·¥å…·å‡½æ•°
-- ==============================================

local function getPlayerSession(player: Player)
    return playerSessions[player]
end

-- ==============================================
-- ç”¨æˆ·è®¤è¯å’Œç®¡ç†
-- ==============================================

function UserService.authenticatePlayer(player: Player)
    local userId = tostring(player.UserId)
    local username = player.Name
    local displayName = player.DisplayName ~= player.Name and player.DisplayName or nil

    local success, userData = DataService.authenticateUser(userId, username, displayName)
    if success then
        -- ä¼˜å…ˆæ£€æŸ¥é…ç½®æ–‡ä»¶ä¸­çš„ç®¡ç†å‘˜ç”¨æˆ·åï¼ˆç«‹å³ç”Ÿæ•ˆï¼‰
        local SharedModules = game:GetService("ReplicatedStorage"):WaitForChild("SharedModules")
        local Config = require(SharedModules:WaitForChild("Config"))
        local defaultAdminUsernames = Config.ADMIN.DEFAULT_ADMIN_USERNAMES or {}

        local isConfigAdmin = false
        for _, adminUsername in ipairs(defaultAdminUsernames) do
            if player.Name == adminUsername then
                isConfigAdmin = true
                print("âš¡ [è®¤è¯] " .. player.Name .. " é€šè¿‡é…ç½®æ–‡ä»¶ç¡®è®¤ä¸ºç®¡ç†å‘˜ï¼ˆç«‹å³ç”Ÿæ•ˆï¼‰")
                break
            end
        end

        -- æ£€æŸ¥æ•°æ®åº“ä¸­çš„ç®¡ç†å‘˜æƒé™
        local isDataAdmin = userData and userData.isAdmin
        local isValidAdminCheck, _ = DataService.checkAdminPermission(userId)

        -- æœ€ç»ˆç®¡ç†å‘˜çŠ¶æ€ï¼šé…ç½®æ–‡ä»¶ä¼˜å…ˆ
        local finalIsAdmin = isConfigAdmin or isDataAdmin or isValidAdminCheck

        if isConfigAdmin then
            print("âœ… [è®¤è¯] " .. player.Name .. " ç®¡ç†å‘˜æƒé™ç«‹å³ç”Ÿæ•ˆï¼ˆæ¥æºï¼šé…ç½®æ–‡ä»¶ï¼‰")
            -- å¼‚æ­¥ç¡®ä¿æ•°æ®åº“ä¸­ä¹Ÿè®¾ç½®äº†ç®¡ç†å‘˜æ ‡è¯†
            spawn(function()
                wait(1)
                local success = pcall(function()
                    local AdminDataService = require(script.Parent.Parent.data:WaitForChild("AdminDataService"))
                    AdminDataService.promoteToAdmin(userId)
                end)
                if success then
                    print("âœ… [è®¤è¯] " .. player.Name .. " æ•°æ®åº“ç®¡ç†å‘˜æ ‡è¯†å·²åŒæ­¥è®¾ç½®")
                else
                    print("âš ï¸ [è®¤è¯] " .. player.Name .. " æ•°æ®åº“ç®¡ç†å‘˜æ ‡è¯†åŒæ­¥å¤±è´¥ï¼Œä½†é…ç½®æ–‡ä»¶æƒé™ä»æœ‰æ•ˆ")
                end
            end)
        elseif isValidAdminCheck then
            print("âš¡ [è®¤è¯] " .. player.Name .. " é€šè¿‡æƒé™æ£€æŸ¥ç¡®è®¤ä¸ºç®¡ç†å‘˜")
        elseif isDataAdmin then
            print("âš¡ [è®¤è¯] " .. player.Name .. " é€šè¿‡ç”¨æˆ·æ•°æ®ç¡®è®¤ä¸ºç®¡ç†å‘˜")
        end

        playerSessions[player] = {
            userId = userId,
            userData = userData,
            authenticated = true,
            isAdmin = finalIsAdmin
        }

        -- å¤„ç†æ¯æ—¥ç™»å½•å¥–åŠ±ï¼ˆå¼‚æ­¥æ‰§è¡Œï¼‰
        spawn(function()
            local rewardSuccess, rewardMessage, rewardData = DataService.claimDailyRewards(userId)
            if rewardSuccess and rewardData and rewardData.totalRewards > 0 then
                print("ğŸ [æ¯æ—¥å¥–åŠ±] " .. player.Name .. " é¢†å–äº† " .. rewardData.totalRewards .. " é‡‘å¸")
                if rewardData.rewardedDays and rewardData.rewardedDays > 1 then
                    print("ğŸ“… [è¡¥å‘å¥–åŠ±] " .. player.Name .. " è¡¥å‘äº† " .. (rewardData.rewardedDays - 1) .. " å¤©çš„å¥–åŠ±")
                end
                -- å¯ä»¥åœ¨è¿™é‡Œé€šçŸ¥å®¢æˆ·ç«¯
            end
        end)

        print("âœ… [è®¤è¯] " .. player.Name .. " è®¤è¯æˆåŠŸ")
        return true
    else
        warn("âŒ [è®¤è¯] " .. player.Name .. " è®¤è¯å¤±è´¥")
        return false
    end
end

function UserService.cleanupPlayer(player: Player)
    if playerSessions[player] then
        local session = playerSessions[player]
        if session.userId then
            -- æ¸…ç†ç”¨æˆ·ä¼šè¯æ•°æ® (DataServiceä½¿ç”¨å†…éƒ¨ä¼šè¯ç®¡ç†)
            pcall(function()
                DataService.clearUserSession(session.userId)
            end)
        end
        playerSessions[player] = nil
        print("ğŸ§¹ [æ¸…ç†] " .. player.Name .. " ä¼šè¯æ•°æ®å·²æ¸…ç†")
    end
end

function UserService.isPlayerAuthenticated(player: Player): boolean
    local session = getPlayerSession(player)
    return session and session.authenticated and DataService.isAuthenticated(session.userId)
end

function UserService.isPlayerAdmin(player: Player): boolean
    -- ä½¿ç”¨æƒé™æ£€æŸ¥
    local userId = tostring(player.UserId)
    local isValidAdminCheck, _ = DataService.checkAdminPermission(userId)

    if isValidAdminCheck then
        print("âš¡ [UserService] " .. player.Name .. " é€šè¿‡æƒé™æ£€æŸ¥éªŒè¯ä¸ºç®¡ç†å‘˜")
        return true
    end

    -- å¤‡ç”¨ï¼šæ£€æŸ¥sessionä¸­çš„isAdminæ ‡å¿—
    local session = getPlayerSession(player)
    local sessionAdmin = session and session.isAdmin

    if sessionAdmin then
        print("âš¡ [UserService] " .. player.Name .. " é€šè¿‡sessionéªŒè¯ä¸ºç®¡ç†å‘˜")
        return true
    end

    print("âŒ [UserService] " .. player.Name .. " ä¸æ˜¯ç®¡ç†å‘˜")
    return false
end

-- åˆ·æ–°ç©å®¶æ•°æ®ï¼ˆç”¨äºå®æ—¶æ›´æ–°ä¼šå‘˜çŠ¶æ€ç­‰ï¼‰
function UserService.refreshPlayerData(player: Player)
    print("ğŸ”„ [UserService] åˆ·æ–°ç©å®¶æ•°æ®:", player.Name)

    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        warn("âŒ [UserService] æ— æ³•åˆ·æ–°æœªè®¤è¯ç”¨æˆ·çš„æ•°æ®:", player.Name)
        return
    end

    -- æ¸…é™¤ä¼šå‘˜çŠ¶æ€ç¼“å­˜ä»¥ç¡®ä¿è·å–æœ€æ–°æ•°æ®
    local UserDataService = DataService.getUserDataService and DataService.getUserDataService() or require(script.Parent.Parent.data:WaitForChild("UserDataService"))
    if UserDataService.clearMembershipCache then
        UserDataService.clearMembershipCache(session.userId)
    end

    -- å‘é€æœ€æ–°çš„ç©å®¶æ•°æ®
    handleGetPlayerData(player)

    print("âœ… [UserService] ç©å®¶æ•°æ®åˆ·æ–°å®Œæˆ:", player.Name)
end

-- ==============================================
-- æ•°æ®å¤„ç†å‡½æ•°
-- ==============================================

local function handleGetPlayerData(player: Player)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        -- å°è¯•é‡æ–°è®¤è¯
        if not UserService.authenticatePlayer(player) then
            Events.User.GetPlayerData:FireClient(player, nil)
            return
        end
        session = getPlayerSession(player)
    end

    -- è·å–æœ€æ–°çš„ç”¨æˆ·æ•°æ®
    local userData = DataService.getUserData(session.userId)
    if userData then
        local inventory = DataService.getUserInventory(session.userId)
        local membershipStatus = DataService.getMembershipStatus(session.userId)

        -- è·å–ç”¨æˆ·äº¤æ˜“è®°å½•
        local transactionSuccess, transactionData, _ = DataService.getUserTransactions(session.userId, 20, 0, nil)

        -- è½¬æ¢ä¸ºå®¢æˆ·ç«¯æ ¼å¼
        local playerData = {
            coins = userData.coins,
            inventory = inventory or {},
            membership = membershipStatus or {
                hasMembership = false,
                isValid = false,
                daysRemaining = 0,
                membershipType = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 0
            },
            stats = {
                totalPurchases = userData.total_purchases or 0,
                totalSales = userData.total_sales or 0,
                totalSpent = userData.total_spent or 0,
                totalEarned = userData.total_earned or 0
            },
            transactionHistory = {}
        }

        -- æ·»åŠ äº¤æ˜“è®°å½•åˆ°ç©å®¶æ•°æ®ä¸­
        if transactionSuccess and transactionData and transactionData.transactions then
            for _, transaction in ipairs(transactionData.transactions) do
                -- ç¡®ä¿æ—¶é—´æˆ³å­—æ®µå­˜åœ¨å’Œæ­£ç¡®
                local createdAt = transaction.created_at or transaction.timestamp or os.time()
                local transactionDate = transaction.transaction_date or os.date("%Y-%m-%d", createdAt)

                table.insert(playerData.transactionHistory, {
                    id = transaction.id,
                    itemId = transaction.item_id,
                    itemName = transaction.item_name,
                    type = transaction.type,
                    quantity = transaction.quantity,
                    unitPrice = transaction.unit_price,
                    totalAmount = transaction.total_amount,
                    transactionDate = transactionDate,
                    createdAt = createdAt,
                    timestamp = createdAt -- ä¸ºäº†å…¼å®¹æ€§
                })
            end
        end

        session.userData = userData
        Events.User.GetPlayerData:FireClient(player, playerData)
    else
        Events.User.GetPlayerData:FireClient(player, nil)
    end
end

local function handleGetShopData(player: Player)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        Events.User.GetShopData:FireClient(player, {})
        return
    end

    local shopItems = DataService.getShopItems()
    if shopItems then
        -- è½¬æ¢æ ¼å¼ä»¥ä¿æŒå…¼å®¹æ€§
        local shopData = {}
        for itemId, item in pairs(shopItems) do
            shopData[itemId] = {
                id = item.id,
                name = item.name,
                price = item.price,
                maxQuantity = item.max_quantity,
                currentStock = item.current_stock,
                description = item.description,
                icon = item.icon,
                imageId = item.image_id,
                category = item.category,
                sellPrice = item.sell_price
            }
        end

        Events.User.GetShopData:FireClient(player, shopData)
    else
        Events.User.GetShopData:FireClient(player, {})
    end
end

local function handleBuyItem(player: Player, itemId: string, quantity: number)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        Events.User.BuyItem:FireClient(player, false, "ç”¨æˆ·æœªè®¤è¯", nil)
        return
    end

    -- éªŒè¯è¾“å…¥
    if not itemId or quantity <= 0 then
        Events.User.BuyItem:FireClient(player, false, "æ— æ•ˆçš„å‚æ•°", nil)
        return
    end

    -- æ£€æŸ¥æ˜¯å¦ä¸ºä¼šå‘˜å•†å“
    local membershipItems = {"monthly_membership", "weekly_membership", "quarterly_membership", "premium_membership", "vip_membership"}
    local isMembershipItem = false
    for _, membershipItemId in ipairs(membershipItems) do
        if itemId == membershipItemId then
            isMembershipItem = true
            break
        end
    end

    local success, message = DataService.buyItem(session.userId, itemId, quantity)

    if success then
        -- å¦‚æœè´­ä¹°çš„æ˜¯ä¼šå‘˜å•†å“ï¼Œç‰¹æ®Šå¤„ç†ç¡®ä¿ä¼šå‘˜çŠ¶æ€æ›´æ–°
        if isMembershipItem then
            local UserDataService = require(script.Parent.Parent.data:WaitForChild("UserDataService"))
            if UserDataService.clearMembershipCache then
                UserDataService.clearMembershipCache(session.userId)
                print("ğŸ§¹ [è´­ä¹°] æ¸…é™¤ä¼šå‘˜ç¼“å­˜:", player.Name, itemId)
            end

            -- ç¨ç­‰ä¸€ä¸‹ç¡®ä¿æ•°æ®å®Œå…¨å†™å…¥
            task.wait(0.2)
            print("âœ… [è´­ä¹°] ä¼šå‘˜å•†å“è´­ä¹°æˆåŠŸï¼Œå‡†å¤‡è·å–æœ€æ–°çŠ¶æ€:", player.Name, itemId)

            -- å†æ¬¡æ¸…é™¤ç¼“å­˜ç¡®ä¿è·å–æœ€æ–°æ•°æ®
            if UserDataService.clearMembershipCache then
                UserDataService.clearMembershipCache(session.userId)
            end
        end

        -- è·å–æ›´æ–°åçš„ç”¨æˆ·æ•°æ®
        local userData = DataService.getUserData(session.userId)
        local inventory = DataService.getUserInventory(session.userId)
        local membershipStatus = DataService.getMembershipStatus(session.userId)

        -- å¦‚æœæ˜¯ä¼šå‘˜å•†å“ï¼Œè®°å½•çŠ¶æ€ç”¨äºè°ƒè¯•
        if isMembershipItem then
            if membershipStatus then
                print("ğŸ” [è´­ä¹°] è·å–åˆ°çš„ä¼šå‘˜çŠ¶æ€:", membershipStatus.hasMembership and "æœ‰ä¼šå‘˜" or "æ— ä¼šå‘˜",
                      "æœ‰æ•ˆ:", membershipStatus.isValid and "æ˜¯" or "å¦",
                      "å‰©ä½™å¤©æ•°:", membershipStatus.daysRemaining or 0)
            else
                print("âš ï¸ [è´­ä¹°] æ— æ³•è·å–ä¼šå‘˜çŠ¶æ€ï¼Œå°†å†æ¬¡å°è¯•")
                task.wait(0.1)
                membershipStatus = DataService.getMembershipStatus(session.userId)
                if membershipStatus then
                    print("ğŸ” [è´­ä¹°] é‡æ–°è·å–ä¼šå‘˜çŠ¶æ€æˆåŠŸ:", membershipStatus.hasMembership and "æœ‰ä¼šå‘˜" or "æ— ä¼šå‘˜",
                          "å‰©ä½™å¤©æ•°:", membershipStatus.daysRemaining or 0)
                end
            end
        end

        local playerData = {
            coins = userData.coins,
            inventory = inventory or {},
            membership = membershipStatus or {
                hasMembership = false,
                isValid = false,
                daysRemaining = 0,
                membershipType = nil,
                startDate = nil,
                endDate = nil,
                dailyReward = 0
            },
            stats = {
                totalPurchases = userData.total_purchases or 0,
                totalSales = userData.total_sales or 0,
                totalSpent = userData.total_spent or 0,
                totalEarned = userData.total_earned or 0
            }
        }

        session.userData = userData
        -- ä¸ºä¼šå‘˜å•†å“è´­ä¹°æä¾›ç‰¹æ®Šæ¶ˆæ¯
        local finalMessage = message
        if isMembershipItem then
            finalMessage = "ä¼šå‘˜è´­ä¹°æˆåŠŸï¼" .. message
        end

        Events.User.BuyItem:FireClient(player, true, finalMessage, playerData)
        print("ğŸ›’ [è´­ä¹°] " .. player.Name .. " è´­ä¹°äº† " .. itemId .. " x" .. quantity)

        -- å¦‚æœè´­ä¹°çš„æ˜¯ä¼šå‘˜å•†å“ï¼Œæ‰“å°ä¼šå‘˜çŠ¶æ€ä¿¡æ¯
        if isMembershipItem and membershipStatus then
            print("ğŸ‘‘ [ä¼šå‘˜] " .. player.Name .. " è´­ä¹°ä¼šå‘˜åçŠ¶æ€:",
                membershipStatus.isValid and "æ¿€æ´»" or "æœªæ¿€æ´»",
                "å‰©ä½™å¤©æ•°:", membershipStatus.daysRemaining or 0)
        end

        -- å¹¿æ’­å•†åº—æ•°æ®æ›´æ–°ç»™æ‰€æœ‰ç©å®¶
        for _, otherPlayer in pairs(Players:GetPlayers()) do
            handleGetShopData(otherPlayer)
        end
    else
        Events.User.BuyItem:FireClient(player, false, message or "è´­ä¹°å¤±è´¥", nil)
    end
end

local function handleSellItem(player: Player, itemId: string, quantity: number)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        Events.User.SellItem:FireClient(player, false, "ç”¨æˆ·æœªè®¤è¯", nil)
        return
    end

    -- éªŒè¯è¾“å…¥
    if not itemId or quantity <= 0 then
        Events.User.SellItem:FireClient(player, false, "æ— æ•ˆçš„å‚æ•°", nil)
        return
    end

    local success, message = DataService.sellItem(session.userId, itemId, quantity)

    if success then
        -- è·å–æ›´æ–°åçš„ç”¨æˆ·æ•°æ®
        local userData = DataService.getUserData(session.userId)
        local inventory = DataService.getUserInventory(session.userId)

        local playerData = {
            coins = userData.coins,
            inventory = inventory or {},
            stats = {
                totalPurchases = userData.total_purchases or 0,
                totalSales = userData.total_sales or 0,
                totalSpent = userData.total_spent or 0,
                totalEarned = userData.total_earned or 0
            }
        }

        session.userData = userData
        Events.User.SellItem:FireClient(player, true, message, playerData)
        print("ğŸ’° [å–å‡º] " .. player.Name .. " å–å‡ºäº† " .. itemId .. " x" .. quantity)

        -- å¹¿æ’­å•†åº—æ•°æ®æ›´æ–°ç»™æ‰€æœ‰ç©å®¶
        for _, otherPlayer in pairs(Players:GetPlayers()) do
            handleGetShopData(otherPlayer)
        end
    else
        Events.User.SellItem:FireClient(player, false, message or "å–å‡ºå¤±è´¥", nil)
    end
end

local function handleRefreshData(player: Player)
    -- åˆ·æ–°ç©å®¶æ•°æ®å’Œå•†åº—æ•°æ®
    handleGetPlayerData(player)
    handleGetShopData(player)
end

local function handleGetTransactions(player: Player, limit: number?, offset: number?, type: string?)
    local session = getPlayerSession(player)
    if not session or not session.authenticated then
        Events.User.GetTransactions:FireClient(player, false, "ç”¨æˆ·æœªè®¤è¯", nil)
        return
    end

    -- è®¾ç½®é»˜è®¤å€¼
    local actualLimit = limit or 50
    local actualOffset = offset or 0

    -- éªŒè¯å‚æ•°
    if actualLimit <= 0 or actualLimit > 100 then
        actualLimit = 50
    end
    if actualOffset < 0 then
        actualOffset = 0
    end

    local success, data, errorMessage = DataService.getUserTransactions(
        session.userId,
        actualLimit,
        actualOffset,
        type
    )

    if success and data then
        -- è½¬æ¢äº¤æ˜“è®°å½•æ ¼å¼ä»¥ä¾›å®¢æˆ·ç«¯ä½¿ç”¨
        local clientTransactions = {}

        if data.transactions then
            for i, transaction in ipairs(data.transactions) do
                -- ç¡®ä¿æ—¶é—´æˆ³å­—æ®µå­˜åœ¨å’Œæ­£ç¡®
                local createdAt = transaction.created_at or transaction.timestamp or os.time()
                local transactionDate = transaction.transaction_date or os.date("%Y-%m-%d", createdAt)

                table.insert(clientTransactions, {
                    id = transaction.id,
                    itemId = transaction.item_id,
                    itemName = transaction.item_name,
                    type = transaction.type,
                    quantity = transaction.quantity,
                    unitPrice = transaction.unit_price,
                    totalAmount = transaction.total_amount,
                    transactionDate = transactionDate,
                    createdAt = createdAt,
                    timestamp = createdAt -- ä¸ºäº†å…¼å®¹æ€§
                })
            end
        end

        -- åŒ…å«åˆ†é¡µå’Œç»Ÿè®¡ä¿¡æ¯
        local responseData = {
            transactions = clientTransactions,
            pagination = data.pagination,
            stats = data.stats
        }

        Events.User.GetTransactions:FireClient(player, true, nil, responseData)
        print("ğŸ“Š [äº¤æ˜“è®°å½•] " .. player.Name .. " è·å–äº† " .. #clientTransactions .. " æ¡äº¤æ˜“è®°å½•")
    else
        local errorMsg = errorMessage or "è·å–äº¤æ˜“è®°å½•å¤±è´¥"
        Events.User.GetTransactions:FireClient(player, false, errorMsg, nil)
        print("âŒ [äº¤æ˜“è®°å½•] " .. player.Name .. " è·å–äº¤æ˜“è®°å½•å¤±è´¥: " .. errorMsg)
    end
end

-- ==============================================
-- äº‹ä»¶è¿æ¥
-- ==============================================

-- è¿æ¥ç”¨æˆ·äº‹ä»¶
Events.User.GetPlayerData.OnServerEvent:Connect(handleGetPlayerData)
Events.User.GetShopData.OnServerEvent:Connect(handleGetShopData)
Events.User.BuyItem.OnServerEvent:Connect(handleBuyItem)
Events.User.SellItem.OnServerEvent:Connect(handleSellItem)
Events.User.RefreshData.OnServerEvent:Connect(handleRefreshData)
Events.User.GetTransactions.OnServerEvent:Connect(handleGetTransactions)


print("ğŸ‘¤ æ™®é€šç”¨æˆ·æœåŠ¡å·²å¯åŠ¨")

return UserService
