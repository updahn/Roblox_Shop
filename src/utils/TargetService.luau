-- é¶å­ç³»ç»ŸæœåŠ¡ç«¯é€»è¾‘
-- ç®¡ç†é¶å­çš„ç”Ÿæˆã€é”€æ¯å’ŒçŠ¶æ€åŒæ­¥

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- ç­‰å¾…å…±äº«æ¨¡å—
local SharedModules = ReplicatedStorage:WaitForChild("SharedModules")
local Config = require(SharedModules:WaitForChild("Config"))
local Events = require(SharedModules:WaitForChild("ShopEvents"))

-- ä½¿ç”¨ç»Ÿä¸€çš„é…ç½®
local DroneConfig = Config.DRONE_CONFIG

local TargetService = {}

-- é¶å­æ•°æ®å­˜å‚¨
local targets = {}
local targetConnections = {}
local nextTargetId = 1

-- é¶å­æ–‡ä»¶å¤¹
local targetsFolder = Workspace:FindFirstChild("Targets")
if not targetsFolder then
    targetsFolder = Instance.new("Folder")
    targetsFolder.Name = "Targets"
    targetsFolder.Parent = Workspace
end

-- åˆ›å»ºå•ä¸ªé¶å­
function TargetService.createTarget(position, customHeight)
    local targetId = "Target_" .. nextTargetId
    nextTargetId = nextTargetId + 1

    -- è®¡ç®—é¶å­é«˜åº¦
    local targetHeight = customHeight
    if not targetHeight and Config.TARGETS.HEIGHT_CONFIG.RANDOM_OFFSET then
        -- ä½¿ç”¨éšæœºé«˜åº¦
        targetHeight = math.random(Config.TARGETS.HEIGHT_CONFIG.MIN_HEIGHT, Config.TARGETS.HEIGHT_CONFIG.MAX_HEIGHT)
    elseif not targetHeight then
        -- ä½¿ç”¨åŸºç¡€é«˜åº¦
        targetHeight = Config.TARGETS.HEIGHT_CONFIG.BASE_HEIGHT
    end

    local targetData = {
        id = targetId,
        position = position,
        height = targetHeight,  -- ä¿å­˜é¶å­çš„å®é™…é«˜åº¦
        health = Config.TARGETS.MAX_HEALTH,
        maxHealth = Config.TARGETS.MAX_HEALTH,
        alive = true,
        respawnTime = 0,
        part = nil
    }

    -- åˆ›å»ºé¶å­æ¨¡å‹
    local targetModel = Instance.new("Model")
    targetModel.Name = targetId
    targetModel.Parent = targetsFolder

    -- è®¡ç®—å®é™…ä½ç½®ï¼ˆåŸºäºåœ°é¢é«˜åº¦å’Œé¶å­é«˜åº¦ï¼‰
    local groundLevel = position.Y - Config.TARGETS.HEIGHT_CONFIG.BASE_HEIGHT
    local actualTargetPos = Vector3.new(position.X, groundLevel + targetHeight, position.Z)

    -- ä¸»ä½“éƒ¨åˆ†ï¼ˆé¶å­æœ¬èº«ï¼‰
    local targetPart = Instance.new("Part")
    targetPart.Name = "Base"
    targetPart.Size = Config.TARGETS.APPEARANCE.SIZE
    targetPart.Position = actualTargetPos
    targetPart.Material = Config.TARGETS.APPEARANCE.MATERIAL
    targetPart.Color = Config.TARGETS.APPEARANCE.COLOR
    targetPart.Anchored = true
    targetPart.CanCollide = false
    targetPart.Parent = targetModel

    -- æ·»åŠ åœ†å½¢é¶å­çº¹ç†
    local frontDecal = Instance.new("Decal")
    frontDecal.Texture = "rbxasset://textures/face.png" -- å¯ä»¥æ›¿æ¢ä¸ºè‡ªå®šä¹‰é¶å­çº¹ç†
    frontDecal.Face = Enum.NormalId.Front
    frontDecal.Parent = targetPart

    -- æ·»åŠ æ”¯æ’‘æ†ï¼ˆåŠ¨æ€é«˜åº¦ï¼‰
    local poleHeight = targetHeight - 3  -- æ”¯æ’‘æ†é«˜åº¦æ¯”é¶å­ä½ç½®ä½3ä¸ªå•ä½
    local pole = Instance.new("Part")
    pole.Name = "Pole"
    pole.Size = Vector3.new(0.5, poleHeight, 0.5)
    pole.Position = Vector3.new(actualTargetPos.X, groundLevel + poleHeight/2, actualTargetPos.Z)
    pole.Material = Enum.Material.Wood
    pole.Color = Color3.fromRGB(139, 69, 19) -- æ£•è‰²
    pole.Anchored = true
    pole.CanCollide = false
    pole.Parent = targetModel

    -- æ·»åŠ åº•åº§
    local base = Instance.new("Part")
    base.Name = "Stand"
    base.Size = Vector3.new(3, 0.5, 3)
    base.Position = Vector3.new(actualTargetPos.X, groundLevel - 0.25, actualTargetPos.Z)
    base.Material = Enum.Material.Concrete
    base.Color = Color3.fromRGB(100, 100, 100) -- ç°è‰²
    base.Anchored = true
    base.CanCollide = true
    base.Parent = targetModel

    -- è®¾ç½®PrimaryPartä¸ºä¸»è¦çš„é¶å­éƒ¨åˆ†
    targetModel.PrimaryPart = targetPart

    -- æ·»åŠ æ ‡è¯†ç‰Œ
    if Config.TARGETS.MARKER.ENABLED then
        local gui = Instance.new("BillboardGui")
        gui.Size = UDim2.new(0, 100, 0, 50)
        gui.StudsOffset = Vector3.new(0, 4, 0)
        gui.Parent = targetPart

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.Text = Config.TARGETS.MARKER.TEXT
        textLabel.TextColor3 = Config.TARGETS.MARKER.TEXT_COLOR
        textLabel.TextSize = Config.TARGETS.MARKER.TEXT_SIZE
        textLabel.TextStrokeTransparency = 0.5
        textLabel.Parent = gui

        -- è¡€æ¡
        local healthBar = Instance.new("Frame")
        healthBar.Size = UDim2.new(0.8, 0, 0.2, 0)
        healthBar.Position = UDim2.new(0.1, 0, 1.2, 0)
        healthBar.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        healthBar.BorderSizePixel = 0
        healthBar.Parent = gui

        local healthFill = Instance.new("Frame")
        healthFill.Size = UDim2.new(1, 0, 1, 0)
        healthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        healthFill.BorderSizePixel = 0
        healthFill.Name = "HealthFill"
        healthFill.Parent = healthBar
    end

    targetData.part = targetPart
    targetData.model = targetModel
    targets[targetId] = targetData

    print("ğŸ¯ åˆ›å»ºé¶å­:", targetId, "ä½ç½®:", position)

    -- é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯é¶å­åˆ›å»º
    Events.Target.TargetCreated:FireAllClients(targetId, {
        position = actualTargetPos,  -- ä½¿ç”¨å®é™…ä½ç½®
        height = targetHeight,       -- åŒ…å«é«˜åº¦ä¿¡æ¯
        health = targetData.health,
        maxHealth = targetData.maxHealth
    })

    return targetData
end

-- æŸåé¶å­
function TargetService.damageTarget(targetId, damage, attackerId)
    local target = targets[targetId]
    if not target or not target.alive then
        return false
    end

    target.health = math.max(0, target.health - damage)

    -- æ›´æ–°è¡€æ¡æ˜¾ç¤º
    if target.part then
        local gui = target.part:FindFirstChild("BillboardGui")
        if gui then
            local healthFill = gui:FindFirstChild("Frame"):FindFirstChild("HealthFill")
            if healthFill then
                local healthPercent = target.health / target.maxHealth
                healthFill.Size = UDim2.new(healthPercent, 0, 1, 0)

                -- æ ¹æ®è¡€é‡æ”¹å˜é¢œè‰²
                if healthPercent > 0.6 then
                    healthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                elseif healthPercent > 0.3 then
                    healthFill.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
                else
                    healthFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                end
            end
        end
    end

    print("ğŸ¯ é¶å­", targetId, "å—åˆ°", damage, "ç‚¹ä¼¤å®³ï¼Œå‰©ä½™è¡€é‡:", target.health)

    -- é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯é¶å­å—æŸ
    Events.Target.TargetDamaged:FireAllClients(targetId, target.health, target.maxHealth, attackerId)

    -- å¦‚æœé¶å­è¢«æ‘§æ¯
    if target.health <= 0 then
        TargetService.destroyTarget(targetId, attackerId)
        return true
    end

    return false
end

-- æ‘§æ¯é¶å­
function TargetService.destroyTarget(targetId, destroyerId)
    local target = targets[targetId]
    if not target or not target.alive then
        return
    end

    target.alive = false
    target.respawnTime = tick() + Config.TARGETS.RESPAWN_TIME

    -- éšè—é¶å­
    if target.model then
        -- éšè—æ¨¡å‹ä¸­çš„æ‰€æœ‰éƒ¨ä»¶
        for _, part in pairs(target.model:GetChildren()) do
            if part:IsA("BasePart") then
                part.Transparency = 1
                part.CanCollide = false
            end
        end

        -- éšè—GUI
        if target.part then
            local gui = target.part:FindFirstChild("BillboardGui")
            if gui then
                gui.Enabled = false
            end
        end
    end

    print("ğŸ’¥ é¶å­", targetId, "è¢«æ‘§æ¯ï¼Œå°†åœ¨", Config.TARGETS.RESPAWN_TIME, "ç§’åé‡ç”Ÿ")

    -- é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯é¶å­è¢«æ‘§æ¯
    Events.Target.TargetDestroyed:FireAllClients(targetId, destroyerId)
end

-- é‡ç”Ÿé¶å­
function TargetService.respawnTarget(targetId)
    local target = targets[targetId]
    if not target or target.alive then
        return
    end

    target.health = target.maxHealth
    target.alive = true
    target.respawnTime = 0

    -- æ˜¾ç¤ºé¶å­
    if target.model then
        -- æ˜¾ç¤ºæ¨¡å‹ä¸­çš„æ‰€æœ‰éƒ¨ä»¶å¹¶æ¢å¤åŸå§‹å±æ€§
        for _, part in pairs(target.model:GetChildren()) do
            if part:IsA("BasePart") then
                if part.Name == "Base" then
                    part.Transparency = 0
                    part.CanCollide = false
                    part.Color = Config.TARGETS.APPEARANCE.COLOR
                elseif part.Name == "Pole" then
                    part.Transparency = 0
                    part.CanCollide = false
                    part.Color = Color3.fromRGB(139, 69, 19)
                elseif part.Name == "Stand" then
                    part.Transparency = 0
                    part.CanCollide = true
                    part.Color = Color3.fromRGB(100, 100, 100)
                end
            end
        end

        -- æ˜¾ç¤ºGUIå¹¶é‡ç½®è¡€æ¡
        if target.part then
            local gui = target.part:FindFirstChild("BillboardGui")
            if gui then
                gui.Enabled = true
                local healthFill = gui:FindFirstChild("Frame"):FindFirstChild("HealthFill")
                if healthFill then
                    healthFill.Size = UDim2.new(1, 0, 1, 0)
                    healthFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                end
            end
        end
    end

    print("ğŸ”„ é¶å­", targetId, "å·²é‡ç”Ÿ")

    -- é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯é¶å­é‡ç”Ÿ
    Events.Target.TargetRespawned:FireAllClients(targetId, {
        position = target.position,
        height = target.height,  -- åŒ…å«é«˜åº¦ä¿¡æ¯
        health = target.health,
        maxHealth = target.maxHealth
    })
end

-- è·å–æœ€è¿‘çš„é¶å­
function TargetService.getNearestTarget(position, maxDistance)
    local nearestTarget = nil
    local nearestDistance = maxDistance or math.huge

    for targetId, target in pairs(targets) do
        if target.alive and target.part then
            local distance = (position - target.part.Position).Magnitude
            if distance < nearestDistance then
                nearestTarget = target
                nearestDistance = distance
            end
        end
    end

    return nearestTarget, nearestDistance
end

-- è·å–æ‰€æœ‰æ´»è·ƒé¶å­
function TargetService.getActiveTargets()
    local activeTargets = {}
    for targetId, target in pairs(targets) do
        if target.alive then
            activeTargets[targetId] = {
                id = targetId,
                position = target.position,
                height = target.height,  -- åŒ…å«é«˜åº¦ä¿¡æ¯
                health = target.health,
                maxHealth = target.maxHealth
            }
        end
    end
    return activeTargets
end

-- åˆå§‹åŒ–é¶å­ç³»ç»Ÿ
function TargetService.initialize()
    print("ğŸ¯ åˆå§‹åŒ–é¶å­ç³»ç»Ÿ...")

    -- ç”Ÿæˆé¶å­
    for i = 1, Config.TARGETS.COUNT do
        local validPosition = false
        local attempts = 0
        local position

        -- å°è¯•æ‰¾åˆ°åˆé€‚çš„ç”Ÿæˆä½ç½®
        while not validPosition and attempts < 50 do
            attempts = attempts + 1

            -- åœ¨é…ç½®çš„èŒƒå›´å†…éšæœºç”Ÿæˆä½ç½®
            local angle = math.random() * 360
            local distance = math.random(Config.TARGETS.SPAWN_AREA.MIN_RADIUS, Config.TARGETS.SPAWN_AREA.MAX_RADIUS)

            local x = Config.TARGETS.SPAWN_AREA.CENTER.X + math.cos(math.rad(angle)) * distance
            local z = Config.TARGETS.SPAWN_AREA.CENTER.Z + math.sin(math.rad(angle)) * distance
            position = Vector3.new(x, Config.TARGETS.SPAWN_AREA.CENTER.Y + Config.TARGETS.HEIGHT_CONFIG.BASE_HEIGHT, z)

            -- æ£€æŸ¥æ˜¯å¦åœ¨æ’é™¤åŒºåŸŸå¤–
            local distanceFromCenter = (Vector3.new(x, 0, z) - Vector3.new(Config.TARGETS.SPAWN_AREA.CENTER.X, 0, Config.TARGETS.SPAWN_AREA.CENTER.Z)).Magnitude
            if distanceFromCenter > Config.TARGETS.SPAWN_AREA.EXCLUDE_RADIUS then
                validPosition = true
            end
        end

        if validPosition then
            TargetService.createTarget(position)
            print("ğŸ¯ é¶å­ " .. i .. " ç”Ÿæˆäºä½ç½®: (" .. math.floor(position.X) .. ", " .. math.floor(position.Y) .. ", " .. math.floor(position.Z) .. ")")
        else
            print("âš ï¸ æ— æ³•ä¸ºé¶å­ " .. i .. " æ‰¾åˆ°åˆé€‚çš„ç”Ÿæˆä½ç½®")
        end
    end

    -- å¯åŠ¨é‡ç”Ÿæ£€æŸ¥å¾ªç¯
    spawn(function()
        while true do
            wait(1)

            for targetId, target in pairs(targets) do
                if not target.alive and target.respawnTime > 0 and tick() >= target.respawnTime then
                    TargetService.respawnTarget(targetId)
                end
            end
        end
    end)

    print("âœ… é¶å­ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œå…±åˆ›å»º", Config.TARGETS.COUNT, "ä¸ªé¶å­")
end

-- æ¸…ç†é¶å­ç³»ç»Ÿ
function TargetService.cleanup()
    -- æ¸…ç†æ‰€æœ‰é¶å­
    for targetId, target in pairs(targets) do
        if target.model then
            target.model:Destroy()
        elseif target.part then
            target.part:Destroy()
        end
    end

    targets = {}
    targetConnections = {}

    print("ğŸ§¹ é¶å­ç³»ç»Ÿå·²æ¸…ç†")
end

-- å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚é¶å­çŠ¶æ€
Events.Target.RequestTargetStatus.OnServerEvent:Connect(function(player)
    local activeTargets = TargetService.getActiveTargets()
    Events.Target.TargetStatusUpdate:FireClient(player, activeTargets)
end)

return TargetService
