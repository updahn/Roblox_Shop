-- åŸºç¡€æœåŠ¡ç±»
-- æä¾›é€šç”¨çš„æœåŠ¡åŠŸèƒ½å’Œæ¥å£

local BaseService = {}
BaseService.__index = BaseService

-- åˆ›å»ºæ–°çš„æœåŠ¡å®ä¾‹
function BaseService.new(serviceName)
    local self = setmetatable({}, BaseService)
    self.name = serviceName or "UnknownService"
    self.isInitialized = false
    self.events = {}
    self.connections = {}
    return self
end

-- åˆå§‹åŒ–æœåŠ¡
function BaseService:initialize()
    if self.isInitialized then
        warn("âš ï¸ [" .. self.name .. "] æœåŠ¡å·²ç»åˆå§‹åŒ–è¿‡äº†")
        return false
    end

    print("ğŸš€ [" .. self.name .. "] æœåŠ¡å¼€å§‹åˆå§‹åŒ–...")

    -- å­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•
    if self.onInitialize then
        local success, error = pcall(self.onInitialize, self)
        if not success then
            warn("âŒ [" .. self.name .. "] åˆå§‹åŒ–å¤±è´¥:", error)
            return false
        end
    end

    self.isInitialized = true
    print("âœ… [" .. self.name .. "] æœåŠ¡åˆå§‹åŒ–å®Œæˆ")
    return true
end

-- é”€æ¯æœåŠ¡
function BaseService:destroy()
    if not self.isInitialized then
        return
    end

    print("ğŸ§¹ [" .. self.name .. "] æœåŠ¡å¼€å§‹é”€æ¯...")

    -- æ–­å¼€æ‰€æœ‰è¿æ¥
    for _, connection in pairs(self.connections) do
        if connection and connection.Disconnect then
            connection:Disconnect()
        end
    end
    self.connections = {}

    -- æ¸…ç†äº‹ä»¶
    for _, event in pairs(self.events) do
        if event and event.Destroy then
            event:Destroy()
        end
    end
    self.events = {}

    -- å­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•
    if self.onDestroy then
        pcall(self.onDestroy, self)
    end

    self.isInitialized = false
    print("âœ… [" .. self.name .. "] æœåŠ¡é”€æ¯å®Œæˆ")
end

-- æ£€æŸ¥æœåŠ¡æ˜¯å¦å·²åˆå§‹åŒ–
function BaseService:isReady()
    return self.isInitialized
end

-- è·å–æœåŠ¡åç§°
function BaseService:getName()
    return self.name
end

-- æ·»åŠ è¿æ¥ï¼ˆè‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸï¼‰
function BaseService:addConnection(connection)
    if connection and connection.Disconnect then
        table.insert(self.connections, connection)
        return connection
    end
    warn("âš ï¸ [" .. self.name .. "] å°è¯•æ·»åŠ æ— æ•ˆçš„è¿æ¥")
    return nil
end

-- åˆ›å»ºå¹¶æ·»åŠ äº‹ä»¶
function BaseService:createEvent(eventName)
    local event = Instance.new("BindableEvent")
    self.events[eventName] = event
    return event
end

-- è·å–äº‹ä»¶
function BaseService:getEvent(eventName)
    return self.events[eventName]
end

-- è§¦å‘äº‹ä»¶
function BaseService:fireEvent(eventName, ...)
    local event = self.events[eventName]
    if event then
        event:Fire(...)
    else
        warn("âš ï¸ [" .. self.name .. "] å°è¯•è§¦å‘ä¸å­˜åœ¨çš„äº‹ä»¶:", eventName)
    end
end

-- ç›‘å¬äº‹ä»¶
function BaseService:connectEvent(eventName, callback)
    local event = self.events[eventName]
    if event then
        local connection = event.Event:Connect(callback)
        self:addConnection(connection)
        return connection
    else
        warn("âš ï¸ [" .. self.name .. "] å°è¯•ç›‘å¬ä¸å­˜åœ¨çš„äº‹ä»¶:", eventName)
        return nil
    end
end

-- è®°å½•æ—¥å¿—ï¼ˆå¯ä»¥è¢«é‡å†™ï¼‰
function BaseService:log(level, message, ...)
    local timestamp = os.date("%H:%M:%S")
    local logMessage = string.format("[%s] [%s] %s: %s", timestamp, level, self.name, message)

    if select("#", ...) > 0 then
        logMessage = logMessage .. " | " .. table.concat({...}, ", ")
    end

    if level == "ERROR" then
        warn(logMessage)
    else
        print(logMessage)
    end
end

-- ä¾¿æ·çš„æ—¥å¿—æ–¹æ³•
function BaseService:logInfo(message, ...)
    self:log("INFO", message, ...)
end

function BaseService:logWarn(message, ...)
    self:log("WARN", message, ...)
end

function BaseService:logError(message, ...)
    self:log("ERROR", message, ...)
end

return BaseService
