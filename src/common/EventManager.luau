-- äº‹ä»¶ç®¡ç†å™¨
-- æä¾›ç»Ÿä¸€çš„äº‹ä»¶ç®¡ç†å’Œé€šä¿¡æœºåˆ¶

local EventManager = {}

-- å†…éƒ¨äº‹ä»¶å­˜å‚¨
local events = {}
local globalConnections = {}

-- åˆ›å»ºä¸€ä¸ªæ–°çš„äº‹ä»¶
function EventManager.createEvent(eventName)
    if events[eventName] then
        warn("âš ï¸ [EventManager] äº‹ä»¶å·²å­˜åœ¨:", eventName)
        return events[eventName]
    end

    local bindableEvent = Instance.new("BindableEvent")
    events[eventName] = bindableEvent

    print("âœ… [EventManager] åˆ›å»ºäº‹ä»¶:", eventName)
    return bindableEvent
end

-- è·å–äº‹ä»¶
function EventManager.getEvent(eventName)
    return events[eventName]
end

-- è§¦å‘äº‹ä»¶
function EventManager.fireEvent(eventName, ...)
    local event = events[eventName]
    if event then
        event:Fire(...)
        print("ğŸ“¡ [EventManager] è§¦å‘äº‹ä»¶:", eventName)
    else
        warn("âŒ [EventManager] äº‹ä»¶ä¸å­˜åœ¨:", eventName)
    end
end

-- ç›‘å¬äº‹ä»¶
function EventManager.connectEvent(eventName, callback)
    local event = events[eventName]
    if not event then
        warn("âŒ [EventManager] äº‹ä»¶ä¸å­˜åœ¨:", eventName)
        return nil
    end

    local connection = event.Event:Connect(callback)

    -- æ·»åŠ åˆ°å…¨å±€è¿æ¥ç®¡ç†
    if not globalConnections[eventName] then
        globalConnections[eventName] = {}
    end
    table.insert(globalConnections[eventName], connection)

    print("ğŸ”— [EventManager] è¿æ¥äº‹ä»¶:", eventName)
    return connection
end

-- æ–­å¼€ç‰¹å®šäº‹ä»¶çš„æ‰€æœ‰è¿æ¥
function EventManager.disconnectEvent(eventName)
    local connections = globalConnections[eventName]
    if connections then
        for _, connection in pairs(connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
        globalConnections[eventName] = {}
        print("ğŸ”Œ [EventManager] æ–­å¼€äº‹ä»¶è¿æ¥:", eventName)
    end
end

-- æ–­å¼€æ‰€æœ‰è¿æ¥
function EventManager.disconnectAll()
    for eventName, connections in pairs(globalConnections) do
        for _, connection in pairs(connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    globalConnections = {}
    print("ğŸ”Œ [EventManager] æ–­å¼€æ‰€æœ‰äº‹ä»¶è¿æ¥")
end

-- é”€æ¯äº‹ä»¶
function EventManager.destroyEvent(eventName)
    local event = events[eventName]
    if event then
        -- å…ˆæ–­å¼€æ‰€æœ‰è¿æ¥
        EventManager.disconnectEvent(eventName)

        -- é”€æ¯äº‹ä»¶å¯¹è±¡
        event:Destroy()
        events[eventName] = nil

        print("ğŸ—‘ï¸ [EventManager] é”€æ¯äº‹ä»¶:", eventName)
    end
end

-- é”€æ¯æ‰€æœ‰äº‹ä»¶
function EventManager.destroyAll()
    EventManager.disconnectAll()

    for eventName, event in pairs(events) do
        if event and event.Destroy then
            event:Destroy()
        end
    end

    events = {}
    print("ğŸ—‘ï¸ [EventManager] é”€æ¯æ‰€æœ‰äº‹ä»¶")
end

-- è·å–äº‹ä»¶ç»Ÿè®¡ä¿¡æ¯
function EventManager.getStats()
    local totalEvents = 0
    local totalConnections = 0

    for eventName, _ in pairs(events) do
        totalEvents = totalEvents + 1
        local connections = globalConnections[eventName]
        if connections then
            totalConnections = totalConnections + #connections
        end
    end

    return {
        totalEvents = totalEvents,
        totalConnections = totalConnections,
        eventNames = {}
    }
end

-- åˆ—å‡ºæ‰€æœ‰äº‹ä»¶
function EventManager.listEvents()
    local eventList = {}
    for eventName, _ in pairs(events) do
        local connectionCount = 0
        if globalConnections[eventName] then
            connectionCount = #globalConnections[eventName]
        end

        table.insert(eventList, {
            name = eventName,
            connections = connectionCount
        })
    end

    return eventList
end

-- æ£€æŸ¥äº‹ä»¶æ˜¯å¦å­˜åœ¨
function EventManager.hasEvent(eventName)
    return events[eventName] ~= nil
end

-- ä¸€æ¬¡æ€§ç›‘å¬äº‹ä»¶ï¼ˆåªè§¦å‘ä¸€æ¬¡åè‡ªåŠ¨æ–­å¼€ï¼‰
function EventManager.connectOnce(eventName, callback)
    local connection
    connection = EventManager.connectEvent(eventName, function(...)
        callback(...)
        if connection then
            connection:Disconnect()

            -- ä»å…¨å±€è¿æ¥ä¸­ç§»é™¤
            local connections = globalConnections[eventName]
            if connections then
                for i, conn in ipairs(connections) do
                    if conn == connection then
                        table.remove(connections, i)
                        break
                    end
                end
            end
        end
    end)

    return connection
end

-- å»¶è¿Ÿè§¦å‘äº‹ä»¶
function EventManager.fireEventDelayed(eventName, delay, ...)
    local args = {...}
    spawn(function()
        wait(delay)
        EventManager.fireEvent(eventName, unpack(args))
    end)
end

-- æ¡ä»¶è§¦å‘äº‹ä»¶ï¼ˆåªæœ‰å½“æ¡ä»¶æ»¡è¶³æ—¶æ‰è§¦å‘ï¼‰
function EventManager.fireEventIf(eventName, condition, ...)
    if condition then
        EventManager.fireEvent(eventName, ...)
        return true
    end
    return false
end

return EventManager
