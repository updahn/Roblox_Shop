-- å•†åº—ç³»ç»Ÿå…±äº«æ•°æ®ç»“æ„ - é‡æ„ä¸ºAPIè°ƒç”¨ç‰ˆæœ¬

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ShopData = {}

-- ç­‰å¾…é…ç½®æ¨¡å—
local SharedModules = ReplicatedStorage:WaitForChild("SharedModules")
local Config = require(SharedModules:WaitForChild("Config"))

-- ç‰©å“æ•°æ®ç»“æ„
export type Item = {
    id: string,
    name: string,
    price: number,
    maxQuantity: number?, -- nilè¡¨ç¤ºæ— é™
    currentStock: number?, -- å½“å‰åº“å­˜
    description: string?,
    icon: string?,
    imageId: string?, -- å•†å“å›¾ç‰‡ID
    category: string?, -- å•†å“åˆ†ç±»
    sellPrice: number? -- å–å‡ºä»·æ ¼ï¼Œå¦‚æœnilåˆ™è‡ªåŠ¨è®¡ç®—ä¸ºåŸä»·*sell_rateï¼ˆä»ç³»ç»Ÿé…ç½®è·å–ï¼‰
}

-- ç©å®¶ç‰©å“æ•°æ®ç»“æ„
export type PlayerItem = {
    itemId: string,
    quantity: number
}

-- ç©å®¶æ•°æ®
export type PlayerData = {
    id: string,
    username: string,
    displayName: string?,
    coins: number,
    items: {[string]: number}, -- itemId -> quantity
    totalEarned: number?,
    totalSpent: number?,
    createdAt: string?,
    lastLogin: string?
}

-- HTTPè¯·æ±‚å·¥å…·
local function makeRequest(method: string, endpoint: string, data: any?, token: string?)
    -- æ£€æŸ¥HTTPæœåŠ¡æ˜¯å¦å¯ç”¨
    if not HttpService.HttpEnabled then
        warn("âŒ HTTPæœåŠ¡æœªå¯ç”¨ï¼Œæ— æ³•è¿æ¥åˆ°APIæœåŠ¡å™¨")
        warn("ğŸ’¡ è§£å†³æ–¹æ¡ˆï¼šåœ¨Roblox Studioä¸­å¯ç”¨HTTPè¯·æ±‚")
        return false, nil
    end
    local url = Config.getApiUrl(endpoint)
    local headers = {}
    for key, value in pairs(Config.API.DEFAULT_HEADERS) do
        headers[key] = value
    end

    if token then
        headers["Authorization"] = "Bearer " .. token
    end

    local requestData = {
        Url = url,
        Method = method,
        Headers = headers
    }

    if data and (method == "POST" or method == "PUT") then
        requestData.Body = HttpService:JSONEncode(data)
    end

    local success, response = pcall(function()
        return HttpService:RequestAsync(requestData)
    end)

    if success then
        if response.Success then
            local responseData = response.Body and HttpService:JSONDecode(response.Body) or {}
            return responseData.success ~= false, responseData
        else
            warn("APIè¯·æ±‚å¤±è´¥ [HTTP " .. (response.StatusCode or "Unknown") .. "]: " .. (response.StatusMessage or "Unknown error"))
            warn("å“åº”å†…å®¹: " .. tostring(response.Body or "æ— å“åº”å†…å®¹"))

            -- å°è¯•è§£æé”™è¯¯å“åº”ä¸­çš„é”™è¯¯ä¿¡æ¯
            local errorInfo = nil
            if response.Body then
                local success_parse, errorData = pcall(function()
                    return HttpService:JSONDecode(response.Body)
                end)
                if success_parse and errorData and errorData.error then
                    errorInfo = {
                        error = errorData.error,
                        statusCode = response.StatusCode
                    }
                end
            end

            return false, errorInfo
        end
    else
        -- æ•è·ç½‘ç»œè¿æ¥é”™è¯¯
        local errorMsg = tostring(response)
        warn("ç½‘ç»œè¯·æ±‚å¼‚å¸¸: " .. errorMsg)

        -- æ£€æŸ¥æ˜¯å¦æ˜¯HTTPæœåŠ¡æœªå¯ç”¨çš„é”™è¯¯
        if string.find(errorMsg, "HttpService") then
            warn("âš ï¸ å¯èƒ½åŸå› ï¼šHTTPæœåŠ¡æœªåœ¨æ¸¸æˆè®¾ç½®ä¸­å¯ç”¨")
            warn("è§£å†³æ–¹æ¡ˆï¼šåœ¨Roblox Studioä¸­å¯ç”¨HTTPè¯·æ±‚æˆ–æ£€æŸ¥æ¸¸æˆçš„HTTPæœåŠ¡è®¾ç½®")
        elseif string.find(errorMsg, "restricted") then
            warn("âš ï¸ å¯èƒ½åŸå› ï¼šHTTPè¯·æ±‚è¢«Robloxå®‰å…¨ç­–ç•¥é˜»æ­¢")
            warn("è§£å†³æ–¹æ¡ˆï¼šæ£€æŸ¥APIæœåŠ¡å™¨åœ°å€æ˜¯å¦åœ¨Robloxå…è®¸çš„åŸŸååˆ—è¡¨ä¸­")
        elseif string.find(errorMsg, "not allowed") then
            warn("âš ï¸ å¯èƒ½åŸå› ï¼šä½¿ç”¨äº†Robloxä¸å…è®¸çš„HTTPè¯·æ±‚å¤´")
            warn("è§£å†³æ–¹æ¡ˆï¼šæ£€æŸ¥è¯·æ±‚å¤´é…ç½®ï¼Œç§»é™¤User-Agentç­‰å—é™åˆ¶çš„è¯·æ±‚å¤´")
        end

        return false, nil
    end
end

-- ç”¨æˆ·è®¤è¯
local userTokens = {} -- å­˜å‚¨ç”¨æˆ·çš„JWT token

function ShopData.authenticateUser(userId: string, username: string, displayName: string?)
    local success, response = makeRequest("POST", "/auth/login", {
        userId = userId,
        username = username,
        displayName = displayName
    })

    if success and response and response.data then
        userTokens[userId] = response.data.token
        return true, response.data.user
    end

    return false, nil
end

function ShopData.getUserToken(userId: string): string?
    return userTokens[userId]
end

-- APIè°ƒç”¨å‡½æ•°

-- è·å–æ‰€æœ‰å•†åº—ç‰©å“
function ShopData.getShopItems(): {[string]: Item}?
    local success, response = makeRequest("GET", "/items")
    if success and response and response.data then
        local items = {}
        for _, item in ipairs(response.data.items) do
            items[item.id] = item
        end
        return items
    end
    return nil
end

-- è·å–ç‰¹å®šç‰©å“
function ShopData.getItem(itemId: string): Item?
    local success, response = makeRequest("GET", "/items/" .. itemId)
    if success and response and response.data then
        return response.data.item
    end
    return nil
end

-- è·å–ç”¨æˆ·æ•°æ®
function ShopData.getUserData(userId: string): PlayerData?
    local token = userTokens[userId]
    if not token then return nil end

    local success, response = makeRequest("GET", "/users/me", nil, token)
    if success and response and response.data then
        return response.data
    end
    return nil
end

-- è·å–ç”¨æˆ·åº“å­˜
function ShopData.getUserInventory(userId: string): {[string]: number}?
    local token = userTokens[userId]
    if not token then return nil end

    local success, response = makeRequest("GET", "/users/inventory", nil, token)
    if success and response and response.data then
        local inventory = {}
        for _, item in ipairs(response.data.inventory) do
            inventory[item.item_id] = item.quantity
        end
        return inventory
    end
    return nil
end

-- è´­ä¹°ç‰©å“
function ShopData.buyItem(userId: string, itemId: string, quantity: number): (boolean, string?)
    local token = userTokens[userId]
    if not token then return false, "æœªè®¤è¯ç”¨æˆ·" end

    local success, response = makeRequest("POST", "/users/buy", {
        itemId = itemId,
        quantity = quantity
    }, token)

    if success and response then
        if response.success then
            return true, response.message
        else
            return false, response.error or "è´­ä¹°å¤±è´¥"
        end
    elseif response and response.error then
        -- APIè¿”å›äº†é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚HTTP 400, 403ç­‰ï¼‰
        return false, response.error
    end
    return false, "ç½‘ç»œè¯·æ±‚å¤±è´¥"
end

-- å‡ºå”®ç‰©å“
function ShopData.sellItem(userId: string, itemId: string, quantity: number): (boolean, string?)
    local token = userTokens[userId]
    if not token then return false, "æœªè®¤è¯ç”¨æˆ·" end

    local success, response = makeRequest("POST", "/users/sell", {
        itemId = itemId,
        quantity = quantity
    }, token)

    if success and response then
        if response.success then
            return true, response.message
        else
            return false, response.error or "å‡ºå”®å¤±è´¥"
        end
    elseif response and response.error then
        -- APIè¿”å›äº†é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚HTTP 400, 403ç­‰ï¼‰
        return false, response.error
    end
    return false, "ç½‘ç»œè¯·æ±‚å¤±è´¥"
end

-- è·å–äº¤æ˜“è®°å½•
function ShopData.getTransactions(userId: string, limit: number?, offset: number?): any?
    local token = userTokens[userId]
    if not token then return nil end

    local endpoint = "/users/transactions"
    if limit or offset then
        endpoint = endpoint .. "?"
        local params = {}
        if limit then table.insert(params, "limit=" .. tostring(limit)) end
        if offset then table.insert(params, "offset=" .. tostring(offset)) end
        endpoint = endpoint .. table.concat(params, "&")
    end

    local success, response = makeRequest("GET", endpoint, nil, token)
    if success and response and response.data then
        return response.data
    end
    return nil
end

-- ç®¡ç†å‘˜åŠŸèƒ½ï¼šè·å–æ‰€æœ‰ç”¨æˆ·
function ShopData.getAllUsers(userId: string, limit: number?, offset: number?): (boolean, any?, string?)
    local token = userTokens[userId]
    if not token then return false, nil, "æœªè®¤è¯ç”¨æˆ·" end

    local endpoint = "/admin/users"
    if limit or offset then
        endpoint = endpoint .. "?"
        local params = {}
        if limit then table.insert(params, "limit=" .. tostring(limit)) end
        if offset then table.insert(params, "offset=" .. tostring(offset)) end
        endpoint = endpoint .. table.concat(params, "&")
    end

    local success, response = makeRequest("GET", endpoint, nil, token)
    if success and response and response.data then
        return true, response.data, nil
    elseif response and response.error then
        return false, nil, response.error
    end
    return false, nil, "ç½‘ç»œè¯·æ±‚å¤±è´¥"
end

-- ç®¡ç†å‘˜åŠŸèƒ½ï¼šä¿®æ”¹ç”¨æˆ·é‡‘å¸
function ShopData.setUserCoins(adminUserId: string, targetUserId: string, newCoins: number, reason: string?): (boolean, string?)
    local token = userTokens[adminUserId]
    if not token then return false, "æœªè®¤è¯ç”¨æˆ·" end

    local success, response = makeRequest("PUT", "/admin/users/" .. targetUserId .. "/coins", {
        coins = newCoins,
        reason = reason
    }, token)

    if success and response then
        if response.success then
            return true, response.message
        else
            return false, response.error or "ä¿®æ”¹å¤±è´¥"
        end
    elseif response and response.error then
        -- APIè¿”å›äº†é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚HTTP 400, 404ç­‰ï¼‰
        return false, response.error
    end
    return false, "ç½‘ç»œè¯·æ±‚å¤±è´¥"
end

-- è·å–ç³»ç»Ÿç»Ÿè®¡
function ShopData.getSystemStats(adminUserId: string): any?
    local token = userTokens[adminUserId]
    if not token then return nil end

    local success, response = makeRequest("GET", "/admin/stats", nil, token)
    if success and response and response.data then
        return response.data
    end
    return nil
end

-- ç³»ç»Ÿé…ç½®ç¼“å­˜
local systemConfig = {
    sell_rate = 0.8 -- é»˜è®¤å€¼
}

-- è·å–ç³»ç»Ÿé…ç½®
function ShopData.getSystemConfig(): any?
    local success, response = makeRequest("GET", "/items/config")
    if success and response and response.data then
        systemConfig.sell_rate = response.data.sell_rate or 0.8
        return response.data
    end
    return nil
end

-- è·å–å–å‡ºä»·æ ¼æ¯”ä¾‹
function ShopData.getSellRate(): number
    return systemConfig.sell_rate
end

-- è®¡ç®—å–å‡ºä»·æ ¼ï¼ˆä½¿ç”¨ç³»ç»Ÿé…ç½®çš„sell_rateï¼‰
function ShopData.calculateSellPrice(price: number): number
    return math.floor(price * systemConfig.sell_rate)
end

return ShopData
